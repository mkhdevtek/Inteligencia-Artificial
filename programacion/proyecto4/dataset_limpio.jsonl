{"prompt": "Estoy intentando evitar un bucle infinito, pero este código no termina nunca:\n\n```python\nx = 10\nwhile x > 0:\n print(x)\n # supuestamente reduzco x\n x = x + 1\n```\n¿Qué estoy haciendo mal?", "response": "Parece que la condición del `while` nunca deja de cumplirse. ¿Cómo está cambiando realmente el valor de `x` dentro del bucle? Piensa en el concepto de *condición de parada* y si tu actualización de la variable se mueve hacia ella o se aleja."}
{"prompt": "Mi código para acceder a los elementos de una lista falla con un error extraño:\n\n```python\nnums = [3, 5, 7, 9]\nfor i in range(len(nums)):\n print(nums[i+1])\n```\n¿Dónde está el problema?", "response": "Observa cómo usas el índice dentro del bucle. ¿Qué ocurre cuando `i` llega a su último valor? Considera el concepto de *límites de índice* en arreglos para evitar salirte del rango permitido."}
{"prompt": "Este algoritmo de búsqueda lineal nunca encuentra el número aunque esté en la lista:\n\n```python\narr = [4, 8, 15, 16, 23, 42]\ntarget = 15\nfor i in range(len(arr)):\n if arr[i] < target:\n print(\"Encontrado!\")\n```\n¿Por qué no funciona?", "response": "Nota la condición de comparación. ¿Tu test realmente verifica igualdad con el objetivo o está probando otra cosa? Piensa en el concepto de *condición lógica correcta* para búsquedas."}
{"prompt": "Estoy simulando una cola, pero nunca se vacía:\n\n```python\nqueue = [1,2,3,4]\nwhile len(queue) > 0:\n print(\"Atendiendo\", queue[0])\n # intento quitar el primero\n queue.append(queue[0])\n queue.pop(0)\n```\n¿Por qué sigue creciendo?", "response": "Fíjate en la operación que haces antes de quitar el primer elemento. ¿Qué efecto tiene agregar un elemento a la misma cola? Reflexiona sobre el concepto de *invariantes* en las estructuras de datos FIFO."}
{"prompt": "Mi bucle para recorrer filas de una matriz causa un error:\n\n```python\nmat = [[1,2],[3,4],[5,6]]\nfor i in range(len(mat)):\n for j in range(len(mat)):\n print(mat[i][j])\n```\n¿Dónde está la falla?", "response": "Revisa cuidadosamente qué tamaño tiene cada dimensión. ¿La segunda dimensión (columnas) usa el mismo rango que la primera? Piensa en el concepto de *longitud adecuada por dimensión* en estructuras bidimensionales."}
{"prompt": "Mi ciclo `while` nunca se detiene aunque la variable debería llegar a 0:\n\n```python\ncount = 5\nwhile count != 0:\n print(count)\n count = count - 2\n```\n¿Por qué no termina?", "response": "Observa cómo estás actualizando `count`. ¿Qué valores toma y en qué momento exacto esperas que sea 0? Reflexiona sobre el concepto de *inaccesibilidad de la condición de parada* en ciclos."}
{"prompt": "Estoy intentando sumar todos los elementos de una lista, pero parece que omito el primero:\n\n```python\narr = [10, 20, 30, 40]\ns = 0\nfor i in range(1, len(arr)):\n s += arr[i]\n```\n¿Qué error tengo?", "response": "Piensa en el punto de inicio de tu iteración. ¿Estás considerando todos los índices válidos? Esto se relaciona con el concepto de *desplazamiento incorrecto del índice inicial*."}
{"prompt": "Mi búsqueda binaria nunca encuentra valores que sí están:\n\n```python\narr = [1,2,3,4,5,6]\nlow, high = 0, len(arr)-1\ntarget = 4\nwhile low < high:\n mid = (low+high)//2\n if arr[mid] < target:\n high = mid - 1\n else:\n low = mid + 1\n```\n¿Por qué no funciona?", "response": "Fíjate en qué variable estás ajustando al comparar. ¿Estás moviendo correctamente los límites hacia donde debería estar el `target`? Considera el concepto de *dirección correcta de ajuste de límites*."}
{"prompt": "Mi cola pierde elementos inesperadamente:\n\n```python\nfrom collections import deque\nq = deque([1,2,3])\nq.popleft()\nq.pop()\n```\nNo entiendo qué está pasando.", "response": "¿Qué diferencia hay entre `popleft()` y `pop()` en una cola? Piensa en el concepto de *operaciones específicas de estructuras FIFO y LIFO*."}
{"prompt": "Este código intenta recorrer una lista al revés, pero falla:\n\n```python\narr = [5,4,3,2,1]\nfor i in range(len(arr)):\n print(arr[-i])\n```\n¿Qué estoy haciendo mal?", "response": "Piensa en cómo funcionan los índices negativos. ¿Qué valor toma `-i` cuando `i` es 0? El concepto clave aquí es *offset correcto al indexar desde el final*."}
{"prompt": "Mi ciclo nunca entra aunque debería:\n\n```python\nx = 5\nwhile x < 5:\n print(x)\n x -= 1\n```\n¿Qué ocurre?", "response": "¿Qué valor inicial tiene `x` y qué condición estás verificando? Analiza el concepto de *condición inicial incompatible*."}
{"prompt": "Estoy intentando buscar un elemento pero el algoritmo sale antes:\n\n```python\narr = [2,4,6,8]\ntarget = 6\nfor x in arr:\n if x > target:\n break\n if x == target:\n print('Encontrado')\n```\n¿Por qué no imprime nada?", "response": "Observa el `break`. ¿Puede estar deteniendo el ciclo antes de llegar al valor buscado? Piensa en el concepto de *orden de condiciones en búsqueda lineal*."}
{"prompt": "Mi simulación de pila no funciona:\n\n```python\nstack = []\nstack.append(1)\nstack.append(2)\nprint(stack.pop(0))\n```\n¿Por qué no se comporta como pila?", "response": "¿Cuál es el índice que debería usarse para desapilar? Reflexiona sobre el concepto de *LIFO y operación correcta de extracción*."}
{"prompt": "Mi código intenta recorrer una matriz, pero me da un error de índice:\n\n```python\nmat = [[1,2,3],[4,5,6]]\nfor i in range(3):\n for j in range(3):\n print(mat[i][j])\n```\n¿Dónde falla?", "response": "¿Cuál es realmente la cantidad de filas y columnas en la matriz? Esto conecta con el concepto de *dimensiones reales vs. asumidas*."}
{"prompt": "Este while parece incrementarse al revés:\n\n```python\nn = 3\nwhile n > 0:\n print(n)\n n = n + 1\n```\n¿Por qué nunca termina?", "response": "¿Tu actualización empuja `n` hacia la condición de salida o la aleja? Piensa en *dirección de actualización de la variable de control*."}
{"prompt": "Intento borrar elementos mientras recorro una lista, pero los saltos están raros:\n\n```python\narr = [1,2,3,4,5]\nfor i in range(len(arr)):\n if arr[i] % 2 == 0:\n arr.pop(i)\n```\n¿Por qué se comporta extraño?", "response": "¿Qué pasa con los índices cuando quitas elementos durante la iteración? Reflexiona sobre el concepto de *modificación concurrente de estructuras iteradas*."}
{"prompt": "Mi búsqueda lineal marca encontrado aunque el valor no está:\n\n```python\narr = [1,2,3]\ntarget = 5\nfor x in arr:\n if x < target:\n print(\"Encontrado\")\n```\n¿Qué pasa?", "response": "¿La comparación que usas realmente verifica igualdad? Piensa en el concepto de *condición errónea en la lógica de comparación*."}
{"prompt": "Mi código intenta ordenar números manualmente, pero entra en un bucle extraño:\n\n```python\narr = [3,1,2]\ni = 0\nwhile i < len(arr):\n if arr[i] > arr[i+1]:\n arr[i], arr[i+1] = arr[i+1], arr[i]\n else:\n i += 1\n```\n¿Dónde está el problema?", "response": "¿Qué ocurre cuando haces `arr[i] > arr[i+1]` en el último índice? El concepto clave es *acceso seguro al elemento siguiente*."}
{"prompt": "Mi algoritmo para encontrar el mínimo falla:\n\n```python\narr = [9,3,7]\nmini = arr[0]\nfor i in range(1,len(arr)):\n if arr[i] > mini:\n mini = arr[i]\n```\n¿Por qué no obtiene el mínimo?", "response": "¿Tu condición está verificando el criterio correcto para un mínimo? Reflexiona sobre *condición de comparación invertida*."}
{"prompt": "Intento usar una cola, pero el frente nunca cambia:\n\n```python\nqueue = [1,2,3]\nfor i in range(len(queue)):\n print(queue[0])\n```\n¿Qué pasa?", "response": "¿Modificar la variable de iteración realmente afecta la estructura? Considera el concepto de *operaciones necesarias para avanzar en una cola*."}
{"prompt": "Mi iteración sobre una cadena falla al final:\n\n```python\ntext = \"hola\"\nfor i in range(len(text)):\n print(text[i+1])\n```\n¿Por qué truena?", "response": "¿Qué valor toma el índice cuando `i` está al final? Piensa en *desbordamiento del índice por desplazamiento extra*."}
{"prompt": "Mi código intenta contar hacia atrás, pero imprime valores inesperados:\n\n```python\nx = 3\nwhile x >= 0:\n print(x)\n x -= 2\n x += 1\n```\n¿Por qué no se detiene donde espero?", "response": "¿Qué efecto neto tienen tus operaciones en cada iteración? Reflexiona sobre *actualización contradictoria de la variable de control*."}
{"prompt": "Intento invertir una lista manualmente, pero obtengo error:\n\n```python\narr = [1,2,3,4]\nrev = []\nfor i in range(len(arr)):\n rev.append(arr[-i])\n```\n¿Qué falla?", "response": "Considera qué ocurre cuando `i` es 0. Piensa en el concepto de *indexación negativa correcta*."}
{"prompt": "Mi algoritmo FIFO nunca termina de procesar:\n\n```python\nqueue = [1,2,3]\nwhile len(queue) > 0:\n queue.append(queue[0])\n queue.pop(0)\n```\n¿Por qué no se vacía?", "response": "¿Qué efecto tiene agregar un elemento antes de quitarlo? Reflexiona sobre *invariancia del tamaño en estructuras de cola*."}
{"prompt": "Mi código de búsqueda binaria se ejecuta pero nunca converge:\n\n```python\narr = [1,2,3,4,5,6]\nlow, high = 0, len(arr)-1\ntarget = 2\nwhile low <= high:\n mid = (low+high)//2\n if arr[mid] > target:\n low = mid + 1\n else:\n high = mid - 1\n```\n¿Qué está mal?", "response": "¿Cómo deberían ajustarse `low` y `high` según la comparación? Considera *dirección correcta de actualización en búsqueda binaria*."}
{"prompt": "Mi bucle debería detenerse al llegar a cero, pero no lo hace:\n\n```python\nn = 4\nwhile n > 0:\n print(n)\n n += 1\n```\n¿Por qué sigue corriendo?", "response": "¿Tu variable `n` se acerca a la condición de salida o se aleja? Piensa en el concepto de *dirección de actualización*."}
{"prompt": "Intento sumar elementos pares, pero parece que salto algunos:\n\n```python\narr = [1,2,3,4,5,6]\nsuma = 0\nfor i in range(0, len(arr), 2):\n suma += arr[i+1]\n```\n¿Qué pasa aquí?", "response": "Cuando avanzas de dos en dos, ¿estás seguro de que `i+1` siempre existe? Este es un problema de *acceso fuera de rango*."}
{"prompt": "Mi código para eliminar elementos de una cola hace cosas raras:\n\n```python\nqueue = [1,2,3,4]\nfor i in range(len(queue)):\n queue.pop(0)\n queue.append(i)\n```\n¿Por qué cambia tanto la cola?", "response": "Piensa si estás mezclando operaciones de eliminación y adición sin considerar cómo afecta el tamaño dinámico. Concepto: *mutación durante iteración*."}
{"prompt": "Trato de hacer una búsqueda lineal, pero siempre marca encontrado:\n\n```python\narr = [10,20,30]\nfor x in arr:\n if x != 50:\n print(\"Encontrado\")\n```\n¿Cuál es el error?", "response": "¿La condición realmente representa que encontraste el objetivo? Reflexiona sobre *condiciones mal formuladas*."}
{"prompt": "Este while debería contar hacia atrás pero se queda en un loop infinito:\n\n```python\nx = 3\nwhile x >= 0:\n print(x)\n x = x + 2\n```\n¿Qué pasa?", "response": "¿Tu actualización empuja a `x` fuera de la condición o la hace verdadera siempre? Piensa en *dirección del cambio*."}
{"prompt": "Mi matriz provoca error al imprimir:\n\n```python\nmat = [[1,2],[3,4],[5,6]]\nfor i in range(3):\n for j in range(3):\n print(mat[j][i])\n```\n¿Qué falla?", "response": "¿Tienen todas las filas tres elementos? Revisa el concepto de *dimensiones reales de la matriz*."}
{"prompt": "Mi código de pila elimina el elemento equivocado:\n\n```python\nstack = [1,2,3]\nvalue = stack.pop(0)\n```\n¿Por qué no retira el último?", "response": "Pop sin índice usa el final. ¿Qué implica usar 0? Piensa en *LIFO vs acceso posicional*."}
{"prompt": "Intento moverme por la lista, pero obtengo un IndexError:\n\n```python\narr = [9,8,7]\nfor i in range(len(arr)+1):\n print(arr[i])\n```\n¿Qué ocurre?", "response": "Tu rango incluye un índice extra. Reflexiona sobre *límites correctos*."}
{"prompt": "Mi búsqueda binaria ejecuta muchas iteraciones inesperadas:\n\n```python\nlow, high = 0, 10\nwhile low < high:\n mid = (low+high)//2\n high = mid\n```\n¿Por qué no converge?", "response": "¿Qué pasa si nunca actualizas `low`? Concepto: *avance de límites*."}
{"prompt": "Quiero recorrer string pero ocurre error:\n\n```python\ns = \"abc\"\nfor i in range(1, len(s)+1):\n print(s[i])\n```\n¿Qué error tengo?", "response": "Los índices válidos terminan en `len(s)-1`. Estás pasando el límite. Concepto: *indexación segura*."}
{"prompt": "Simulo cola pero nunca se vacía:\n\n```python\nqueue = [1,2,3]\nwhile queue:\n queue.append(queue.pop(0))\n```\n¿Por qué?", "response": "¿El tamaño de la cola está cambiando realmente? Piensa en *efecto neto de las operaciones*."}
{"prompt": "Mi ciclo debería contar ascendente, pero no avanza:\n\n```python\nx = 0\nwhile x < 5:\n print(x)\n x -= 1\n```\n¿Por qué se queda así?", "response": "¿El valor se acerca a la condición de salida o se aleja? Concepto: *progresión hacia la meta*."}
{"prompt": "Intento buscar un valor pero el bucle termina antes:\n\n```python\narr = [1,3,5,7]\nfor x in arr:\n if x > 3:\n break\n if x == 5:\n print(\"Ok\")\n```\n¿Por qué no imprime?", "response": "¿El `break` evita llegar al valor objetivo? Piensa en *orden de condiciones*."}
{"prompt": "Mi recorrido de matriz genera error:\n\n```python\nmat = [[1],[2],[3]]\nfor i in range(3):\n print(mat[i][1])\n```\n¿Por qué falla?", "response": "¿Todas las filas tienen al menos dos columnas? Concepto: *heterogeneidad de filas*."}
{"prompt": "Intento invertir una cadena manualmente, pero salta la primera letra:\n\n```python\ns = \"hello\"\nrev = \"\"\nfor i in range(len(s)):\n rev += s[-i]\n```\n¿Qué ocurre?", "response": "Considera qué pasa cuando i=0. Concepto: *uso correcto de índices negativos*."}
{"prompt": "Mi conteo no para donde quiero:\n\n```python\nn = 10\nwhile n != 1:\n print(n)\n n -= 3\n```\n¿Por qué no llega a 1?", "response": "¿Es posible que restar 3 alcance exactamente 1? Piensa en *condiciones de parada inalcanzables*."}
{"prompt": "La pila parece invertir mis valores sola:\n\n```python\nstack = [1,2,3]\nstack.insert(0,4)\n```\n¿Por qué?", "response": "Insertar en 0 no es operación de pila. Concepto: *comportamiento esperado LIFO*."}
{"prompt": "Mi lista se procesa raro al eliminar elementos:\n\n```python\narr = [1,2,3,4]\nfor x in arr:\n if x % 2 == 0:\n arr.remove(x)\n```\n¿Por qué brinca elementos?", "response": "Eliminar mientras iteras modifica la secuencia. Concepto: *mutación durante iteración*."}
{"prompt": "Mi búsqueda lineal termina muy pronto:\n\n```python\narr=[5,4,3]\ntarget=3\nfor x in arr:\n if x < target:\n break\n if x == target:\n print(\"found\")\n```\n¿Por qué no funciona?", "response": "El `break` ocurre antes del valor. Concepto: *condición prematura*."}
{"prompt": "Mi while debería recorrer enteros, pero nunca entra:\n\n```python\nx = 5\nwhile x < 3:\n print(x)\n x -= 1\n```\n¿Qué pasa?", "response": "La condición inicial no se cumple. Concepto: *inicio incompatible*."}
{"prompt": "Mi matriz 2D produce valores incorrectos:\n\n```python\nmat=[[1,2,3],[4,5,6]]\nfor i in range(len(mat[0])):\n for j in range(len(mat)):\n print(mat[i][j])\n```\n¿Por qué?", "response": "Estás invirtiendo los índices. Concepto: *orden correcto de filas y columnas*."}
{"prompt": "Mi código colapsa al buscar en array:\n\n```python\narr=[1,2,3]\nfor i in range(len(arr)):\n if arr[i+1] == 2:\n print('ok')\n```\n¿Dónde está el error?", "response": "Cuando i está al final, `i+1` no existe. Concepto: *límite superior incorrecto*."}
{"prompt": "Mi cola no procesa elementos en orden esperado:\n\n```python\nqueue=[1,2,3]\nqueue.pop()\n```\n¿Qué ocurre?", "response": "`pop()` sin índice actúa como pila. Concepto: *operación FIFO incorrecta*."}
{"prompt": "El bucle debería imprimir del 1 al 5, pero no imprime nada:\n\n```python\nx = 1\nwhile x > 5:\n print(x)\n x += 1\n```\n¿Qué sucede?", "response": "La condición nunca se cumple desde el inicio. Concepto: *evaluación inicial de condición*."}
{"prompt": "Mi búsqueda binaria parece invertida:\n\n```python\nlow, high = 0, 5\nwhile low < high:\n mid = (low+high)//2\n if mid < 2:\n high = mid-1\n else:\n low = mid+1\n```\n¿Por qué no converge?", "response": "¿Estás comparando `mid` en lugar del valor del arreglo? Concepto: *comparación incorrecta*."}
{"prompt": "Intento duplicar elementos, pero obtengo bucle infinito:\n\n```python\narr=[1]\nwhile len(arr) < 10:\n arr.append(arr[-1])\n arr.append(arr[-1])\n```\n¿Por qué crece tan rápido?", "response": "¿Duplicas más de lo necesario cada iteración? Concepto: *crecimiento exponencial no controlado*."}
{"prompt": "Mi bucle imprime elementos repetidos:\n\n```python\narr=[1,2,3]\nfor i in range(len(arr)):\n print(arr[0])\n```\n¿Dónde está el error?", "response": "Estás siempre accediendo a index 0. Concepto: *uso incorrecto del índice de iteración*."}
{"prompt": "Mi búsqueda no encuentra nada:\n\n```python\narr=[8,6,7]\ntarget=6\nfor i in range(len(arr)):\n if i == target:\n print('found')\n```\n¿Qué está mal?", "response": "Comparas índice con valor. Concepto: *comparación equivocada*."}
{"prompt": "Mi matriz se imprime diagonal pero yo quería fila por fila:\n\n```python\nmat=[[1,2],[3,4]]\nfor i in range(2):\n print(mat[i][i])\n```\n¿Qué pasa?", "response": "Estás recorriendo solo posiciones iguales. Concepto: *recorrido parcial no intencional*."}
{"prompt": "Mi while nunca termina:\n\n```python\nx=1\nwhile x != 10:\n print(x)\n x += 3\n```\n¿Por qué?", "response": "¿La suma de 3 alcanza exactamente 10? Concepto: *objetivo inalcanzable*."}
{"prompt": "Intento simular cola pero el orden se invierte:\n\n```python\nqueue=[1,2,3]\nqueue.insert(0,4)\n```\n¿Por qué?", "response": "Insertar al inicio rompe comportamiento FIFO. Concepto: *operación fuera del modelo*."}
{"prompt": "Mi recorrido de array salta valores:\n\n```python\narr=[1,2,3,4]\nfor i in range(len(arr)):\n i += 1\n print(arr[i])\n```\n¿Qué error tengo?", "response": "Modificar el índice dentro del loop no afecta `range`. Concepto: *confusión entre contador y índice*."}
{"prompt": "Mi código produce IndexError:\n\n```python\narr=[1,2]\nprint(arr[2])\n```\n¿Por qué?", "response": "Los índices válidos son 0 y 1. Concepto: *límite superior excluyente*."}
{"prompt": "Mi búsqueda binaria nunca encuentra el valor al final:\n\n```python\nlow=0\nhigh=5\nwhile low<high:\n mid=(low+high)//2\n low=mid+1\n```\n¿Por qué?", "response": "Nunca verificas si `mid` es el valor buscado. Concepto: *omisión de condición de éxito*."}
{"prompt": "Mi pila termina vacía antes de lo que quiero:\n\n```python\nstack=[1,2,3]\nfor i in range(len(stack)):\n stack.pop()\n```\n¿Qué ocurre?", "response": "Popear reduce la longitud mientras la recorres. Concepto: *mutación de la estructura*."}
{"prompt": "Mi while no se ejecuta como espero:\n\n```python\nx=10\nwhile x:\n print(x)\n x = x + 1\n```\n¿Por qué no para?", "response": "`x` nunca llega a cero. Concepto: *control de condición booleana*."}
{"prompt": "Mi matriz produce error en iteración:\n\n```python\nmat=[[1,2],[3,4]]\nfor i in range(3):\n print(mat[0][i])\n```\n¿Por qué?", "response": "La fila solo tiene 2 columnas. Concepto: *exceder longitud interna*."}
{"prompt": "Intento recorrer caracteres pero se duplica salida:\n\n```python\ns=\"hi\"\nfor c in s:\n print(s[0])\n```\n¿Qué hice mal?", "response": "Imprimes posición fija, no el iterado. Concepto: *ignorar variable de iteración*."}
{"prompt": "Mi ciclo retrocede mal:\n\n```python\nn=5\nwhile n>0:\n n -= 2\n n += 1\n```\n¿Por qué tantas iteraciones?", "response": "Los cambios se cancelan parcialmente. Concepto: *actualizaciones contradictorias*."}
{"prompt": "Mi búsqueda omite valores:\n\n```python\narr=[1,3,5]\nfor i in range(0,len(arr),2):\n if arr[i]==3:\n print('ok')\n```\n¿Por qué no encuentra 3?", "response": "De tres elementos solo revisas índices 0 y 2. Concepto: *salto de iteración*."}
{"prompt": "Mi cola crece en vez de reducirse:\n\n```python\nqueue=[1,2]\nwhile queue:\n queue.append(queue[0])\n```\n¿Qué pasa?", "response": "Nunca quitas elementos. Concepto: *falta de operación primaria*."}
{"prompt": "Mi busqueda binaria no funciona:\n\n```python\narr=[1,2,3]\nlow=0\nhigh=2\nwhile low<high:\n mid=low\n```\n¿Por qué?", "response": "Si `mid` no cambia, el bucle nunca avanza. Concepto: *invariancia de variable pivot*."}
{"prompt": "Mi matriz genera orden extraño:\n\n```python\nmat=[[1,2],[3,4]]\nfor i in range(2):\n for j in range(2):\n print(mat[j][i])\n```\n¿Por qué?", "response": "Estás transponiendo sin querer. Concepto: *orden de índices*."}
{"prompt": "Mi while se queda atorado:\n\n```python\nx=0\nwhile x < 3:\n print(x)\n```\n¿Por qué nunca termina?", "response": "Nunca actualizas `x`. Concepto: *variable de control estática*."}
{"prompt": "Mi lista se recorre mal:\n\n```python\narr=[4,5,6]\nfor i in range(len(arr)):\n print(arr[-i+1])\n```\n¿Por qué imprime raro?", "response": "Cuando i=1, -i+1=0. Concepto: *cálculo incorrecto de índices negativos*."}
{"prompt": "Mi pila pierde elementos inesperadamente:\n\n```python\nstack=[1,2,3]\nstack.remove(3)\n```\n¿Por qué no es pop?", "response": "`remove` elimina por valor, no como pila. Concepto: *operación LIFO mal elegida*."}
{"prompt": "Mi búsqueda lineal se salta valores:\n\n```python\narr=[2,4,6]\nfor i in range(len(arr)):\n i+=1\n if arr[i]==6:\n print('yes')\n```\n¿Qué pasa?", "response": "Modificar i dentro del for no afecta la iteración real. Concepto: *confusión contador-índice*."}
{"prompt": "Mi código para sumar números pares se queda ejecutando infinitamente:\n```python\nnum = 0\nsuma = 0\nwhile num < 10:\n if num % 2 == 0:\n suma += num\nprint(suma)\n```", "response": "Entiendo tu frustración. Tu lógica para identificar números pares es correcta, pero observa detenidamente tu bucle `while`. ¿Qué le está pasando a la variable `num` en cada iteración? Para que un bucle `while` termine, la variable de control debe modificarse dentro del bucle. En tu caso, `num` siempre vale 0, por lo que la condición `num < 10` siempre será verdadera. **Concepto clave**: Todo bucle `while` necesita una **variable de progreso** que eventualmente haga falsa la condición de parada. ¿Qué línea de código te falta agregar dentro del bucle?"}
{"prompt": "Mi función para encontrar el máximo en un array devuelve resultados incorrectos:\n```python\ndef encontrar_maximo(arr):\n maximo = 0\n for i in range(len(arr)):\n if arr[i] > maximo:\n maximo = arr[i]\n return maximo\n\nprint(encontrar_maximo([-5, -2, -8, -1])) # Devuelve 0\n```", "response": "Buen intento con la lógica de comparación. Sin embargo, fíjate en el resultado cuando todos los números son negativos. ¿Por qué crees que devuelve 0? El problema está en tu **inicialización** de `maximo`. Al comenzar con 0, estás asumiendo que siempre habrá al menos un número mayor que cero en el array. **Concepto clave**: Al buscar extremos (máximo/mínimo), debes inicializar con un valor del propio array o con infinity negativo/positivo. ¿Con qué valor deberías inicializar `maximo` para que funcione con cualquier array, incluso si todos los números son negativos?"}
{"prompt": "Mi implementación de una cola usando lista no funciona correctamente:\n```python\nclass Cola:\n def __init__(self):\n self.items = []\n \n def encolar(self, item):\n self.items.append(item)\n \n def desencolar(self):\n if len(self.items) > 0:\n return self.items.pop()\n return None\n\ncola = Cola()\ncola.encolar(1)\ncola.encolar(2)\ncola.encolar(3)\nprint(cola.desencolar()) # Esperaba 1, pero sale 3\n```", "response": "Tu implementación está muy cerca de ser correcta. El problema no es de sintaxis, sino de **comprensión del concepto de cola**. Observa qué elemento estás eliminando con `pop()`. Las colas siguen el principio **FIFO (First In, First Out)**: el primer elemento en entrar debe ser el primero en salir. Sin embargo, `pop()` sin argumentos elimina el último elemento de la lista (comportamiento de una **pila/stack**, que es LIFO). **Concepto clave**: En Python, `pop()` elimina del final, mientras que `pop(0)` elimina del inicio. ¿Qué deberías modificar en el método `desencolar()` para respetar el orden FIFO de una cola?"}
{"prompt": "Mi búsqueda binaria no encuentra elementos que sé que están en el array:\n```python\ndef busqueda_binaria(arr, objetivo):\n low = 0\n high = len(arr) - 1\n \n while low < high:\n mid = (low + high) // 2\n if arr[mid] == objetivo:\n return mid\n elif arr[mid] < objetivo:\n low = mid\n else:\n high = mid\n return -1\n\narr = [1, 3, 5, 7, 9, 11, 13]\nprint(busqueda_binaria(arr, 13)) # Devuelve -1 en lugar de 6\n```", "response": "Tu estructura general de búsqueda binaria es correcta, pero hay un error sutil en cómo actualizas los límites. Observa tu condición `while low < high` y cómo modificas `low` y `high`. ¿Qué pasa cuando el objetivo está en la última posición y `mid` se acerca a `high`? El problema es doble: (1) Tu condición debería ser `while low <= high` para verificar también cuando ambos índices son iguales, y (2) al actualizar los límites, estás usando `low = mid` y `high = mid`, lo que puede crear un **bucle infinito** o excluir el elemento buscado. **Concepto clave**: En búsqueda binaria, después de comparar con `mid`, debes excluir ese índice de la siguiente búsqueda usando `low = mid + 1` o `high = mid - 1`. ¿Puedes identificar qué ajustes necesitas en las líneas donde actualizas `low` y `high`?"}
{"prompt": "Mi código para invertir un array in-place no funciona correctamente:\n```python\ndef invertir_array(arr):\n for i in range(len(arr)):\n temp = arr[i]\n arr[i] = arr[len(arr) - 1 - i]\n arr[len(arr) - 1 - i] = temp\n return arr\n\nprint(invertir_array([1, 2, 3, 4, 5])) # Devuelve [1, 2, 3, 4, 5]\n```", "response": "Tu lógica de intercambio es correcta, estás usando la técnica apropiada con una variable temporal. Sin embargo, piensa en lo que sucede cuando tu bucle avanza. ¿Cuántos intercambios realmente necesitas hacer? Si tienes 5 elementos, ¿necesitas hacer 5 intercambios? El problema es que estás recorriendo **todo el array** cuando solo deberías recorrer **hasta la mitad**. Al llegar a la mitad, ya has intercambiado todos los elementos necesarios. Si continúas, ¡vuelves a intercambiarlos y el array regresa a su estado original! **Concepto clave**: Para invertir in-place, solo necesitas intercambiar elementos hasta la mitad del array. ¿Cómo deberías modificar el `range()` de tu bucle `for` para iterar solo hasta la mitad?"}
{"prompt": "Mi código para verificar si un número es primo siempre devuelve False:\n```python\ndef es_primo(n):\n if n < 2:\n return False\n for i in range(2, n):\n if n % i != 0:\n return False\n return True\n\nprint(es_primo(7)) # Devuelve False, debería ser True\n```", "response": "Tu estructura es buena, pero hay un error en la lógica de verificación. Piensa en lo que significa que un número sea primo: debe ser divisible **solo** por 1 y por sí mismo. Ahora mira tu condición `if n % i != 0`. ¿Qué estás verificando aquí? Estás retornando `False` en el **primer** divisor que NO divide exactamente a `n`. Pero para que un número sea primo, debe **no ser divisible** por ningún número en ese rango. **Concepto clave**: Debes buscar UN divisor que SÍ divida exactamente (`n % i == 0`) para confirmar que NO es primo. Si terminas el bucle sin encontrar ningún divisor, entonces SÍ es primo. ¿Ves cómo tu condición está invertida?"}
{"prompt": "Mi implementación de pila no elimina elementos correctamente:\n```python\nclass Pila:\n def __init__(self):\n self.items = []\n self.tope = -1\n \n def apilar(self, item):\n self.items.append(item)\n self.tope += 1\n \n def desapilar(self):\n if self.tope >= 0:\n self.tope -= 1\n return self.items[self.tope]\n return None\n\npila = Pila()\npila.apilar('A')\npila.apilar('B')\nprint(pila.desapilar()) # Sale 'A' en lugar de 'B'\n```", "response": "Tu gestión del índice `tope` es casi correcta, pero hay un problema de **orden de operaciones**. Observa cuidadosamente la secuencia en `desapilar()`: primero decrementas `tope` y luego accedes a `items[tope]`. ¿Qué posición estás accediendo después de decrementar? Si `tope` era 1 (apuntando a 'B'), al decrementar se convierte en 0, y entonces accedes a `items[0]` que es 'A'. **Concepto clave**: Debes **primero** guardar el elemento en la posición actual del tope, **luego** decrementar. O alternativamente, acceder a `items[tope]` antes de decrementar. ¿Cómo reorganizarías las líneas en `desapilar()` para obtener el elemento correcto?"}
{"prompt": "Mi algoritmo de ordenamiento burbuja no ordena completamente el array:\n```python\ndef burbuja(arr):\n n = len(arr)\n for i in range(n):\n for j in range(n - 1):\n if arr[j] > arr[j + 1]:\n arr[j], arr[j + 1] = arr[j + 1], arr[j]\n return arr\n\nprint(burbuja([5, 2, 8, 1, 9])) # A veces no ordena correctamente\n```", "response": "Tu lógica de intercambio es perfecta, pero hay una ineficiencia que puede causar problemas. Observa el rango del bucle interno: `range(n - 1)`. Esto significa que siempre comparas casi todos los elementos, incluso los que ya están ordenados. Después de cada iteración completa del bucle externo, el elemento más grande 'burbujea' hasta el final. **Concepto clave**: En la iteración `i`, los últimos `i` elementos ya están en su posición final, por lo que no necesitas compararlos de nuevo. El bucle interno debería ser `range(n - 1 - i)` para evitar comparaciones innecesarias y asegurar que el algoritmo termine correctamente. ¿Ves cómo esto optimiza y corrige el algoritmo?"}
{"prompt": "Mi función para contar vocales en una cadena no cuenta correctamente:\n```python\ndef contar_vocales(texto):\n vocales = 'aeiou'\n contador = 0\n for letra in texto:\n if letra in vocales:\n contador += 1\n else:\n contador = 0\n return contador\n\nprint(contar_vocales('hola mundo')) # Devuelve 0 en lugar de 4\n```", "response": "Tu lógica para identificar vocales es correcta, pero hay un problema grave en tu contador. Observa qué sucede con la variable `contador` cuando encuentras una letra que **no** es vocal. ¿Por qué estás reiniciando el contador a 0? Piensa en lo que significa 'contar': debes **acumular** todas las vocales encontradas durante todo el recorrido. **Concepto clave**: Un contador debe incrementarse cuando se cumple la condición y simplemente **no hacer nada** (continuar) cuando no se cumple. Al reiniciar el contador en cada consonante, pierdes el conteo acumulado. ¿Qué deberías hacer con el bloque `else`?"}
{"prompt": "Mi búsqueda lineal devuelve el índice incorrecto:\n```python\ndef buscar(arr, objetivo):\n indice = -1\n for i in range(len(arr)):\n if arr[i] == objetivo:\n indice = i\n return indice\n\nprint(buscar([3, 7, 2, 7, 9], 7)) # Devuelve 3 en lugar de 1\n```", "response": "Tu código técnicamente funciona, pero no hace lo que probablemente esperas. Observa que tu bucle recorre **todo** el array sin detenerse. ¿Qué pasa cuando el elemento buscado aparece múltiples veces? Como no detienes el bucle al encontrar la primera coincidencia, `indice` se sigue actualizando con cada ocurrencia. Al final, devuelves el índice de la **última** aparición, no de la primera. **Concepto clave**: En búsqueda lineal, normalmente queremos encontrar la **primera** ocurrencia y detener la búsqueda inmediatamente con `return i` dentro del `if`. Esto es más eficiente y cumple la expectativa típica. ¿Deberías seguir buscando después de encontrar el elemento?"}
{"prompt": "Mi código para calcular factorial devuelve 0:\n```python\ndef factorial(n):\n resultado = 0\n for i in range(1, n + 1):\n resultado *= i\n return resultado\n\nprint(factorial(5)) # Devuelve 0 en lugar de 120\n```", "response": "Tu estructura de bucle es correcta y estás multiplicando cada número como debe ser. Sin embargo, hay un error crítico en la **inicialización**. ¿Qué sucede cuando multiplicas cualquier número por 0? Siempre obtienes 0. Al inicializar `resultado = 0`, todas las multiplicaciones posteriores serán 0, sin importar los valores de `i`. **Concepto clave**: Para operaciones de multiplicación acumulativa (como factorial o producto de elementos), debes inicializar con **1** (el elemento neutro de la multiplicación), no con 0. De forma similar, las sumas acumulativas se inicializan con 0. ¿Con qué valor deberías inicializar `resultado`?"}
{"prompt": "Mi función para encontrar duplicados no funciona:\n```python\ndef tiene_duplicados(arr):\n for i in range(len(arr)):\n for j in range(len(arr)):\n if i != j and arr[i] == arr[j]:\n return True\n return False\n\nprint(tiene_duplicados([1, 2, 3, 4, 5])) # A veces da resultados incorrectos\n```", "response": "Tu lógica de comparación es correcta, pero hay una **ineficiencia crítica** que puede causar problemas. Observa el bucle interno: `range(len(arr))`. Esto significa que estás comparando cada elemento con **todos** los elementos, incluyendo los anteriores que ya comparaste. Por ejemplo, cuando `i=2`, vuelves a comparar con `j=0` y `j=1`, que ya verificaste cuando `i` valía 0 y 1. **Concepto clave**: Para evitar comparaciones duplicadas y mejorar eficiencia, el bucle interno debería empezar **después** del índice actual: `range(i + 1, len(arr))`. Así cada par se compara solo una vez. ¿Ves cómo esto optimiza el algoritmo?"}
{"prompt": "Mi código para eliminar un elemento de un array tiene comportamiento extraño:\n```python\ndef eliminar_valor(arr, valor):\n for i in range(len(arr)):\n if arr[i] == valor:\n arr.pop(i)\n return arr\n\nprint(eliminar_valor([1, 2, 2, 3, 2, 4], 2)) # No elimina todos los 2\n```", "response": "Aquí hay un problema clásico al **modificar una estructura mientras la recorres**. Piensa en qué sucede cuando eliminas un elemento: todos los elementos posteriores se desplazan una posición hacia la izquierda. Si en la posición 1 tienes un 2 y lo eliminas, el siguiente 2 que estaba en la posición 2 ahora está en la posición 1. Pero tu índice `i` avanza a 2, ¡saltándote ese elemento! **Concepto clave**: No debes modificar una lista mientras la iteras con su índice. Las soluciones incluyen: (1) iterar hacia atrás, (2) crear una nueva lista con los elementos que quieres mantener, o (3) usar comprensión de listas. ¿Cuál de estas alternativas te parece más clara?"}
{"prompt": "Mi implementación de merge (fusión) de dos arrays ordenados no funciona:\n```python\ndef merge(arr1, arr2):\n resultado = []\n i = 0\n j = 0\n while i < len(arr1) and j < len(arr2):\n if arr1[i] < arr2[j]:\n resultado.append(arr1[i])\n i += 1\n else:\n resultado.append(arr2[j])\n j += 1\n return resultado\n\nprint(merge([1, 3, 5], [2, 4, 6, 8])) # Devuelve [1, 2, 3, 4, 5, 6]\n```", "response": "Tu lógica de comparación y fusión es excelente, pero falta algo importante. Observa tu condición `while`: se detiene cuando **uno** de los arrays se agota. ¿Qué pasa con los elementos restantes del otro array? En tu ejemplo, el 8 nunca se agrega porque cuando `i` llega al final de `arr1`, el bucle termina, aunque `arr2` todavía tiene elementos. **Concepto clave**: Después del bucle principal, debes agregar los elementos **restantes** de ambos arrays (solo uno tendrá elementos sobrantes). Esto se hace típicamente con `resultado.extend(arr1[i:])` y `resultado.extend(arr2[j:])`. ¿Ves qué te falta después del bucle `while`?"}
{"prompt": "Mi código para rotar un array hacia la derecha no funciona correctamente:\n```python\ndef rotar_derecha(arr, k):\n for _ in range(k):\n ultimo = arr[len(arr) - 1]\n for i in range(len(arr) - 1):\n arr[i] = arr[i + 1]\n arr[0] = ultimo\n return arr\n\nprint(rotar_derecha([1, 2, 3, 4, 5], 2)) # Da resultado incorrecto\n```", "response": "Tu idea de mover elementos uno por uno es válida, pero hay un error en la **dirección del desplazamiento**. Observa tu bucle interno: estás copiando `arr[i + 1]` en `arr[i]`, lo que desplaza elementos hacia la **izquierda**, no hacia la derecha. Si quieres rotar a la derecha, cada elemento debe moverse a la posición siguiente. **Concepto clave**: Para rotar derecha, debes iterar el array **en reversa** (desde el penúltimo hasta el inicio) y copiar `arr[i]` en `arr[i + 1]`. Alternativamente, podrías usar slicing: `arr = arr[-k:] + arr[:-k]`. ¿Ves por qué tu bucle actual hace lo opuesto?"}
{"prompt": "Mi función para verificar si una cadena es palíndromo no funciona con frases:\n```python\ndef es_palindromo(texto):\n inicio = 0\n fin = len(texto) - 1\n while inicio < fin:\n if texto[inicio] != texto[fin]:\n return False\n inicio += 1\n fin -= 1\n return True\n\nprint(es_palindromo('Anita lava la tina')) # Devuelve False\n```", "response": "Tu algoritmo de comparación de dos punteros es perfecto para arrays, pero hay un problema al aplicarlo a cadenas con **espacios y mayúsculas**. Observa: estás comparando 'A' con 'a', y ' ' (espacio) con 't'. Los palíndromos de frases normalmente ignoran espacios, puntuación y diferencias de mayúsculas/minúsculas. **Concepto clave**: Antes de verificar, debes **normalizar** la cadena: eliminar espacios, convertir a minúsculas (o mayúsculas), y remover caracteres no alfabéticos. Puedes hacer esto con `texto = texto.replace(' ', '').lower()` al inicio. ¿Ves cómo el preprocesamiento es crucial para este tipo de validaciones?"}
{"prompt": "Mi búsqueda del segundo elemento mayor devuelve resultados incorrectos:\n```python\ndef segundo_mayor(arr):\n mayor = arr[0]\n segundo = arr[0]\n for num in arr:\n if num > mayor:\n segundo = mayor\n mayor = num\n return segundo\n\nprint(segundo_mayor([5, 2, 8, 8, 3])) # Devuelve 8 en lugar de 5\n```", "response": "Tu lógica para actualizar el mayor es correcta, pero hay un problema con cómo manejas los casos donde aparecen **duplicados del mayor**. ¿Qué pasa cuando encuentras otro 8? Solo actualizas `mayor` cuando `num > mayor`, pero nunca actualizas `segundo` cuando `num` es mayor que `segundo` pero menor que `mayor`. Además, inicializar ambos con `arr[0]` es problemático. **Concepto clave**: Necesitas una condición adicional `elif num > segundo and num < mayor` para actualizar correctamente el segundo mayor. También considera inicializar con valores muy pequeños (float('-inf')) o validar que haya al menos 2 elementos distintos. ¿Qué condición te falta?"}
{"prompt": "Mi código para insertar en posición específica de un array no funciona:\n```python\ndef insertar_en(arr, pos, valor):\n arr.append(0)\n for i in range(pos, len(arr)):\n arr[i + 1] = arr[i]\n arr[pos] = valor\n return arr\n\nprint(insertar_en([1, 2, 3, 4], 2, 99)) # Da IndexError\n```", "response": "Tu estrategia de agregar espacio y desplazar elementos es correcta en concepto, pero hay un error de **orden y límites**. Cuando haces `arr[i + 1] = arr[i]` comenzando desde `pos`, estás intentando acceder a `i + 1` que podría estar fuera del rango del array. Además, estás desplazando hacia la derecha pero no has considerado que debes hacerlo **en reversa** para no sobrescribir valores. **Concepto clave**: Para insertar, debes desplazar elementos **de derecha a izquierda** (desde el final hacia la posición de inserción) usando `range(len(arr) - 1, pos, -1)`. Así cada elemento se mueve antes de ser sobrescrito. ¿Ves por qué el orden importa?"}
{"prompt": "Mi función para encontrar la subsecuencia de suma máxima no funciona:\n```python\ndef suma_maxima(arr):\n suma_actual = 0\n suma_max = 0\n for num in arr:\n suma_actual += num\n if suma_actual > suma_max:\n suma_max = suma_actual\n if suma_actual < 0:\n suma_actual = 0\n return suma_max\n\nprint(suma_maxima([-2, -3, -1, -4])) # Devuelve 0, debería ser -1\n```", "response": "Tu implementación del algoritmo de Kadane es casi perfecta para arrays con números positivos, pero falla con arrays **completamente negativos**. ¿Qué devuelves cuando todos los números son negativos? Devuelves 0, pero el máximo real sería el número menos negativo (-1 en este caso). El problema está en inicializar `suma_max = 0`. **Concepto clave**: Debes inicializar `suma_max` con el primer elemento del array o con `float('-inf')` para que funcione correctamente con todos los números negativos. Esto asegura que siempre captures la suma máxima real, incluso si es negativa. ¿Con qué valor deberías inicializar `suma_max`?"}
{"prompt": "Mi implementación de selección sort no ordena correctamente:\n```python\ndef seleccion_sort(arr):\n n = len(arr)\n for i in range(n):\n min_idx = i\n for j in range(i, n):\n if arr[j] < arr[min_idx]:\n min_idx = j\n arr[i], arr[min_idx] = arr[min_idx], arr[i]\n return arr\n\nprint(seleccion_sort([64, 25, 12, 22, 11])) # A veces no ordena bien\n```", "response": "Tu algoritmo está muy cerca de ser correcto, pero hay un detalle sutil en el **rango del bucle interno**. Observa que usas `range(i, n)`, lo que significa que comienzas buscando desde la posición `i`. ¿Qué elemento estás comparando primero? Estás comparando `arr[i]` consigo mismo, lo cual es innecesario pero no incorrecto. Sin embargo, el verdadero problema es que deberías buscar el mínimo en la **porción no ordenada**, que comienza **después** de `i`. **Concepto clave**: El bucle interno debería ser `range(i + 1, n)` para buscar el mínimo solo en los elementos que aún no están ordenados. Esto evita comparaciones redundantes y asegura la correcta lógica del algoritmo. ¿Ves la diferencia?"}
{"prompt": "Mi código para eliminar duplicados de un array ordenado modifica incorrectamente:\n```python\ndef eliminar_duplicados(arr):\n if len(arr) == 0:\n return arr\n j = 0\n for i in range(1, len(arr)):\n if arr[i] != arr[i - 1]:\n j += 1\n arr[j] = arr[i]\n return arr\n\nprint(eliminar_duplicados([1, 1, 2, 2, 3, 4, 4])) # El array completo sigue teniendo duplicados\n```", "response": "Tu algoritmo de dos punteros es correcto para identificar y compactar elementos únicos, pero hay un problema con lo que **devuelves**. Observa: estás modificando el array in-place correctamente, colocando los elementos únicos al principio, pero luego devuelves el array **completo**. Los elementos duplicados al final siguen ahí. **Concepto clave**: Debes devolver solo la **porción relevante** del array modificado. Esto se hace con `arr[:j+1]` para retornar solo los primeros `j+1` elementos que contienen los valores únicos. Alternativamente, podrías devolver el número de elementos únicos y que el llamador use ese valor. ¿Qué parte del array modificado deberías devolver?"}
{"prompt": "Mi función para verificar paréntesis balanceados no funciona:\n```python\ndef parentesis_balanceados(expresion):\n contador = 0\n for char in expresion:\n if char == '(':\n contador += 1\n elif char == ')':\n contador -= 1\n return contador == 0\n\nprint(parentesis_balanceados('))(('))) # Devuelve True, debería ser False\n```", "response": "Tu idea de usar un contador es buena para verificar que haya la **misma cantidad** de paréntesis de apertura y cierre, pero no verifica el **orden**. Observa tu ejemplo: hay 2 '(' y 2 ')', entonces el contador termina en 0, pero la expresión no está balanceada porque cierras antes de abrir. **Concepto clave**: No solo debe haber igual cantidad, sino que en ningún momento el contador debe ser **negativo** (lo que indicaría un cierre sin apertura previa). Debes verificar `if contador < 0: return False` dentro del bucle. Una pila es la estructura ideal para este problema. ¿Qué validación adicional necesitas durante el recorrido?"}
{"prompt": "Mi código para calcular la media de un array devuelve resultados incorrectos:\n```python\ndef calcular_media(arr):\n suma = 0\n for num in arr:\n suma += num\n media = suma / len(arr)\n return int(media)\n\nprint(calcular_media([1, 2, 3, 4, 5])) # Devuelve 3 en lugar de 3.0\n```", "response": "Tu cálculo de la suma y la división son correctos, pero hay una decisión de diseño problemática al final. ¿Por qué estás convirtiendo el resultado a entero con `int()`? La media de [1, 2, 3, 4, 5] es efectivamente 3.0, pero la media de [1, 2, 3, 4] es 2.5, no 2. Al convertir a entero, estás **perdiendo información** (la parte decimal) mediante truncamiento. **Concepto clave**: La media es un valor de punto flotante por naturaleza. No debes forzar la conversión a entero a menos que específicamente necesites el piso del valor. Simplemente devuelve `media` sin convertir. ¿En qué casos sería problemática esta conversión a int?"}
{"prompt": "Mi implementación de inserción en lista enlazada al inicio no funciona:\n```python\nclass Nodo:\n def __init__(self, dato):\n self.dato = dato\n self.siguiente = None\n\nclass ListaEnlazada:\n def __init__(self):\n self.cabeza = None\n \n def insertar_inicio(self, dato):\n nuevo = Nodo(dato)\n nuevo.siguiente = self.cabeza\n self.cabeza = self.cabeza.siguiente\n\nlista = ListaEnlazada()\nlista.insertar_inicio(1)\nlista.insertar_inicio(2) # Se pierde el nodo 1\n```", "response": "Tu creación del nuevo nodo y el enlace inicial son correctos, pero hay un error crítico en la **última línea**. Observa: estás haciendo `self.cabeza = self.cabeza.siguiente` cuando debería ser `self.cabeza = nuevo`. Piensa en qué estás haciendo: después de crear `nuevo` y hacer que apunte a la cabeza actual, estás moviendo `self.cabeza` al **siguiente nodo** en lugar de al nuevo nodo que acabas de crear. **Concepto clave**: Para insertar al inicio, debes: (1) hacer que el nuevo nodo apunte a la cabeza actual, (2) hacer que la cabeza apunte al nuevo nodo. Tu error está en el paso 2. ¿A qué debería apuntar `self.cabeza`?"}
{"prompt": "Mi código para encontrar el elemento más frecuente no funciona con empates:\n```python\ndef mas_frecuente(arr):\n frecuencias = {}\n for num in arr:\n if num in frecuencias:\n frecuencias[num] += 1\n else:\n frecuencias[num] = 1\n \n max_freq = 0\n elemento = None\n for num, freq in frecuencias.items():\n if freq > max_freq:\n max_freq = freq\n elemento = num\n return elemento\n\nprint(mas_frecuente([1, 2, 2, 3, 3, 3, 1, 1, 1])) # Comportamiento inconsistente\n```", "response": "Tu conteo de frecuencias es perfecto, y tu lógica para encontrar el máximo es correcta en general. Sin embargo, hay un problema sutil relacionado con el **orden de iteración** en diccionarios. Cuando hay empates (1 y 3 aparecen ambos 4 veces), ¿cuál devuelves? Depende del orden en que iteras el diccionario, que en Python 3.7+ mantiene el orden de inserción, pero esto puede no ser lo que esperas. **Concepto clave**: Debes definir claramente qué hacer en caso de empate: ¿devolver el primero que aparece, el último, el menor valor, o todos? Para el primero, deberías usar `>=` en lugar de `>`. Para comportamiento consistente, considera ordenar o especificar el criterio de desempate. ¿Qué comportamiento esperas en caso de empate?"}
{"prompt": "Mi código para verificar si un array está ordenado no funciona correctamente:\n```python\ndef esta_ordenado(arr):\n for i in range(len(arr)):\n if arr[i] > arr[i + 1]:\n return False\n return True\n\nprint(esta_ordenado([1, 2, 3, 4, 5])) # Da IndexError\n```", "response": "Tu lógica de comparación es correcta, pero hay un error de **límites del array**. Observa que estás accediendo a `arr[i + 1]` dentro del bucle. ¿Qué pasa cuando `i` es el último índice válido? Intentarías acceder a `arr[len(arr)]`, que está fuera de rango. **Concepto clave**: Cuando comparas elementos consecutivos, debes asegurarte de no salirte del array. Tu bucle debería ser `range(len(arr) - 1)` para que la última comparación sea entre `arr[len(arr)-2]` y `arr[len(arr)-1]`. ¿Hasta qué índice deberías iterar?"}
{"prompt": "Mi función para contar ocurrencias de un elemento devuelve resultados incorrectos:\n```python\ndef contar_ocurrencias(arr, objetivo):\n contador = 0\n for i in range(len(arr)):\n if arr[i] == objetivo:\n contador += 1\n break\n return contador\n\nprint(contar_ocurrencias([1, 2, 3, 2, 2, 4], 2)) # Devuelve 1 en lugar de 3\n```", "response": "Tu lógica de identificación y conteo es correcta, pero hay un problema con el **control de flujo**. Observa la instrucción `break` dentro del `if`. ¿Qué hace `break`? Sale del bucle inmediatamente. Entonces, cuando encuentras la primera ocurrencia del objetivo, incrementas el contador y sales, sin revisar el resto del array. **Concepto clave**: `break` se usa cuando quieres detener la búsqueda al encontrar el primer resultado. Para contar **todas** las ocurrencias, debes recorrer todo el array sin interrupciones. ¿Deberías usar `break` en este caso?"}
{"prompt": "Mi implementación de suma de dígitos recursiva no funciona:\n```python\ndef suma_digitos(n):\n if n == 0:\n return 0\n return (n % 10) + suma_digitos(n / 10)\n\nprint(suma_digitos(12345)) # Da error o resultado incorrecto\n```", "response": "Tu caso base es correcto y la idea de separar el último dígito con `n % 10` es perfecta. Sin embargo, hay un problema de **tipo de dato** en la llamada recursiva. Observa que usas `n / 10`, lo que en Python 3 produce un **float** (número decimal), no un entero. Entonces en la siguiente iteración, `n % 10` no funcionará correctamente con un float. **Concepto clave**: Para división entera (que descarta la parte decimal), debes usar el operador `//` en lugar de `/`. Así `n // 10` te da 1234 en lugar de 1234.5. ¿Qué operador deberías usar para división entera?"}
{"prompt": "Mi código para intercambiar dos variables no funciona:\n```python\ndef intercambiar(a, b):\n a = b\n b = a\n return a, b\n\nx = 5\ny = 10\nx, y = intercambiar(x, y)\nprint(x, y) # Devuelve 10, 10 en lugar de 10, 5\n```", "response": "Aquí hay un problema clásico de **sobrescritura de valores**. Observa la secuencia: primero haces `a = b`, entonces `a` ahora vale lo mismo que `b`. Luego haces `b = a`, pero `a` ya no tiene su valor original, ¡tiene el valor de `b`! Entonces ambas variables terminan con el mismo valor. **Concepto clave**: Para intercambiar, necesitas una **variable temporal** para guardar uno de los valores antes de sobrescribirlo: `temp = a; a = b; b = temp`. En Python, puedes usar intercambio simultáneo: `a, b = b, a`. ¿Por qué se pierde el valor original de `a`?"}
{"prompt": "Mi búsqueda del elemento mínimo en array rotado no funciona:\n```python\ndef encontrar_minimo(arr):\n minimo = arr[0]\n for i in range(len(arr)):\n if arr[i] < minimo:\n minimo = arr[i - 1]\n return minimo\n\nprint(encontrar_minimo([4, 5, 6, 7, 0, 1, 2])) # Devuelve 7 en lugar de 0\n```", "response": "Tu estrategia de buscar el mínimo comparando con cada elemento es válida, pero hay un error en la **asignación**. Cuando encuentras un elemento menor que el mínimo actual, ¿qué haces? Asignas `arr[i - 1]` en lugar de `arr[i]`. Piensa: si `arr[i]` es menor que `minimo`, ¿no debería `arr[i]` ser el nuevo mínimo? Al asignar `arr[i - 1]`, estás tomando el elemento **anterior** al que acabas de determinar que es más pequeño. **Concepto clave**: Cuando encuentras un elemento que cumple tu condición (ser menor), ese mismo elemento es el que debes guardar, no su vecino. ¿Qué índice deberías usar en la asignación?"}
{"prompt": "Mi código para sumar matrices no funciona correctamente:\n```python\ndef sumar_matrices(A, B):\n resultado = []\n for i in range(len(A)):\n fila = []\n for j in range(len(A[0])):\n fila.append(A[i][j] + B[i][j])\n resultado.append(fila)\n return resultado\n\nA = [[1, 2], [3, 4]]\nB = [[5, 6, 7], [8, 9, 10]]\nprint(sumar_matrices(A, B)) # Da IndexError\n```", "response": "Tu algoritmo de doble bucle para sumar matrices es correcto, pero falta una **validación crucial**. Observa las dimensiones: `A` es 2x2 y `B` es 2x3. ¿Se pueden sumar? No, porque para sumar matrices deben tener las **mismas dimensiones**. Tu código intenta acceder a `B[i][j]` asumiendo que `B` tiene la misma estructura que `A`, lo que causa el error. **Concepto clave**: Antes de realizar operaciones matriciales, debes verificar que las dimensiones son compatibles: `len(A) == len(B) and len(A[0]) == len(B[0])`. Si no coinciden, debes retornar un error o None. ¿Qué validación deberías agregar al inicio?"}
{"prompt": "Mi implementación de Fibonacci recursiva devuelve valores negativos:\n```python\ndef fibonacci(n):\n if n <= 1:\n return n\n return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(-5)) # Devuelve -5, debería manejar el error\n```", "response": "Tu implementación recursiva es correcta para números positivos, pero no maneja **casos inválidos**. ¿Qué significa Fibonacci de un número negativo? No está definido matemáticamente. Tu caso base `if n <= 1: return n` devuelve el número tal cual si es 0, 1, o negativo, pero para negativos esto no tiene sentido. **Concepto clave**: Debes agregar **validación de entrada** al principio de la función. Si `n < 0`, deberías retornar un error, -1, o None indicando entrada inválida. La secuencia de Fibonacci solo está definida para enteros no negativos. ¿Qué deberías verificar antes de procesar?"}
{"prompt": "Mi código para encontrar la intersección de dos arrays tiene duplicados:\n```python\ndef interseccion(arr1, arr2):\n resultado = []\n for num in arr1:\n if num in arr2:\n resultado.append(num)\n return resultado\n\nprint(interseccion([1, 2, 2, 3], [2, 2, 3, 4])) # Devuelve [2, 2, 3] en lugar de [2, 3]\n```", "response": "Tu lógica para verificar si un elemento está en ambos arrays es correcta, pero no estás considerando **duplicados**. Observa: recorres `arr1` y cada vez que encuentras un elemento que está en `arr2`, lo agregas. Si el elemento aparece múltiples veces en `arr1`, lo agregarás múltiples veces al resultado. **Concepto clave**: Una intersección típicamente devuelve elementos **únicos** que aparecen en ambos conjuntos. Debes verificar también `if num not in resultado` antes de agregar, o usar una estructura de conjunto: `set(arr1) & set(arr2)`. ¿Cómo evitarías agregar duplicados al resultado?"}
{"prompt": "Mi función para validar si un año es bisiesto no funciona para todos los casos:\n```python\ndef es_bisiesto(anio):\n if anio % 4 == 0:\n return True\n return False\n\nprint(es_bisiesto(1900)) # Devuelve True, debería ser False\n```", "response": "Tu primera verificación es correcta (divisible entre 4), pero las reglas de años bisiestos son más complejas. ¿Conoces la regla completa? Un año es bisiesto si es divisible entre 4, **excepto** los años divisibles entre 100 (que no son bisiestos), **excepto** los divisibles entre 400 (que sí son bisiestos). 1900 es divisible entre 4 y 100, pero no entre 400, entonces NO es bisiesto. **Concepto clave**: Necesitas verificaciones anidadas: `if anio % 400 == 0: return True; elif anio % 100 == 0: return False; elif anio % 4 == 0: return True; else: return False`. ¿Qué casos especiales te faltan?"}
{"prompt": "Mi código para convertir decimal a binario está incompleto:\n```python\ndef decimal_a_binario(n):\n binario = ''\n while n > 0:\n binario = str(n % 2) + binario\n n = n // 2\n return binario\n\nprint(decimal_a_binario(0)) # Devuelve '' en lugar de '0'\n```", "response": "Tu algoritmo de división sucesiva es correcto y la construcción de la cadena está bien hecha. Sin embargo, hay un **caso especial** que no estás manejando. ¿Qué pasa cuando `n` es 0? El bucle `while n > 0` nunca se ejecuta, entonces devuelves una cadena vacía. Pero el binario de 0 es '0', no una cadena vacía. **Concepto clave**: Los algoritmos de conversión a menudo tienen casos especiales en los límites. Debes agregar una verificación al inicio: `if n == 0: return '0'` antes del bucle while. Alternativamente, usa `while n >= 0` pero necesitarías un break. ¿Qué caso borde te falta manejar?"}
{"prompt": "Mi implementación de potencia recursiva no funciona con exponentes negativos:\n```python\ndef potencia(base, exponente):\n if exponente == 0:\n return 1\n return base * potencia(base, exponente - 1)\n\nprint(potencia(2, -3)) # Recursión infinita\n```", "response": "Tu caso base y recursión son correctos para exponentes positivos, pero no manejas **exponentes negativos**. ¿Qué pasa cuando `exponente` es -3? Sigues restando 1 (-3, -4, -5...) y nunca llegas a 0, causando recursión infinita. Matemáticamente, `base^(-n) = 1 / base^n`. **Concepto clave**: Necesitas agregar otro caso: `if exponente < 0: return 1 / potencia(base, -exponente)`. Esto convierte el exponente negativo en positivo y toma el recíproco del resultado. ¿Qué validación adicional necesitas para exponentes negativos?"}
{"prompt": "Mi código para encontrar elementos únicos no funciona correctamente:\n```python\ndef elementos_unicos(arr):\n unicos = []\n for num in arr:\n if num not in unicos:\n unicos.append(num)\n else:\n unicos.remove(num)\n return unicos\n\nprint(elementos_unicos([1, 2, 2, 3, 3, 3, 4])) # Resultado incorrecto\n```", "response": "Hay un problema conceptual aquí. Parece que quieres encontrar elementos que aparecen exactamente una vez, pero tu lógica es problemática. Cuando encuentras un duplicado, lo eliminas de `unicos`, pero ¿qué pasa con el tercer 3? El primer 3 se agrega, el segundo se elimina, el tercero se vuelve a agregar. **Concepto clave**: Para encontrar elementos únicos (que aparecen una sola vez), deberías primero **contar todas las ocurrencias** con un diccionario, luego filtrar los que tienen cuenta == 1. Tu enfoque actual no puede distinguir entre elementos que aparecen 2 veces vs 3+ veces. ¿Deberías procesar el array en dos pasadas?"}
{"prompt": "Mi búsqueda de substring no encuentra todas las ocurrencias:\n```python\ndef encontrar_substring(texto, patron):\n posiciones = []\n pos = texto.find(patron)\n while pos != -1:\n posiciones.append(pos)\n pos = texto.find(patron, pos + len(patron))\n return posiciones\n\nprint(encontrar_substring('abababa', 'aba')) # Devuelve [0, 4] en lugar de [0, 2, 4]\n```", "response": "Tu uso de `find()` es correcto y la estructura del bucle está bien, pero hay un problema con cómo avanzas en el texto. Observa que buscas la siguiente ocurrencia desde `pos + len(patron)`. Esto funciona para patrones no solapados, pero ¿qué pasa con patrones que se solapan? En 'abababa', 'aba' aparece en posiciones 0, 2, y 4, pero al saltar `len(patron)` posiciones, te saltas la del medio. **Concepto clave**: Para encontrar ocurrencias solapadas, debes avanzar solo 1 posición: `pos = texto.find(patron, pos + 1)`. ¿Deberías saltar todo el patrón o solo un carácter?"}
{"prompt": "Mi código para calcular el MCD (Máximo Común Divisor) usando el algoritmo de Euclides falla:\n```python\ndef mcd(a, b):\n while b != 0:\n temp = b\n b = a % b\n a = b\n return a\n\nprint(mcd(48, 18)) # Devuelve 0 en lugar de 6\n```", "response": "Tu comprensión del algoritmo de Euclides es buena: usas el módulo y actualizas las variables. Sin embargo, hay un error en la **secuencia de asignaciones**. Observa: guardas `b` en `temp`, calculas `a % b` y lo asignas a `b`, pero luego asignas `b` (el nuevo valor, que es el residuo) a `a`. Has perdido el valor original de `b` que guardaste en `temp`. **Concepto clave**: Debes hacer `a = temp` (o simplemente `a = b` antes de reasignar `b`). La secuencia correcta es: guardar el valor viejo de `b`, actualizar `b` con el residuo, actualizar `a` con el valor viejo de `b`. ¿Ves dónde no estás usando `temp` correctamente?"}
{"prompt": "Mi función para verificar si dos strings son anagramas no funciona:\n```python\ndef son_anagramas(str1, str2):\n if len(str1) != len(str2):\n return False\n for char in str1:\n if char in str2:\n str2 = str2.replace(char, '', 1)\n else:\n return False\n return True\n\nprint(son_anagramas('listen', 'silent')) # Funciona\nprint(son_anagramas('aab', 'aba')) # Funciona\nprint(son_anagramas('aabb', 'abab')) # Puede fallar\n```", "response": "Tu enfoque de eliminar caracteres encontrados es creativo, pero tiene un problema sutil de **eficiencia y corrección**. Cuando modificas strings repetidamente con `replace()`, estás creando nuevos strings en cada operación (las strings son inmutables en Python). Además, `replace(char, '', 1)` solo elimina la primera ocurrencia, pero no garantiza que las frecuencias sean exactas si hay caracteres repetidos en posiciones diferentes. **Concepto clave**: El método más confiable es **ordenar ambos strings** y compararlos (`sorted(str1) == sorted(str2)`) o usar un diccionario/Counter para comparar frecuencias de caracteres. ¿Hay una forma más directa de verificar si tienen los mismos caracteres con las mismas frecuencias?"}
{"prompt": "Mi código para remover espacios duplicados no funciona:\n```python\ndef remover_espacios_duplicados(texto):\n resultado = ''\n for i in range(len(texto)):\n if texto[i] == ' ' and texto[i + 1] == ' ':\n continue\n resultado += texto[i]\n return resultado\n\nprint(remover_espacios_duplicados('hola mundo !')) # Da IndexError\n```", "response": "Tu lógica de comparar caracteres consecutivos es buena, pero hay un error de **límites**. ¿Qué pasa cuando `i` está en el último carácter? Intentas acceder a `texto[i + 1]`, que está fuera de rango. Este es un error muy común al comparar elementos consecutivos. **Concepto clave**: Debes iterar solo hasta `len(texto) - 1` para poder acceder de forma segura a `i + 1`, o verificar `i < len(texto) - 1` antes de acceder al siguiente carácter. También considera qué hacer con el último carácter si es un espacio. ¿Hasta qué índice deberías iterar?"}
{"prompt": "Mi implementación de inserción ordenada en lista no funciona:\n```python\ndef insertar_ordenado(arr, valor):\n i = 0\n while i < len(arr) and arr[i] < valor:\n i += 1\n arr.insert(i, valor)\n return arr\n\nprint(insertar_ordenado([1, 3, 5, 7], 4)) # Funciona\nprint(insertar_ordenado([1, 3, 5, 7], 8)) # Funciona\nprint(insertar_ordenado([], 5)) # Funciona, pero hay un caso problemático\n```", "response": "Tu algoritmo es casi perfecto para la mayoría de casos. Encuentras correctamente la posición donde insertar usando un bucle while. Sin embargo, piensa en arrays con **elementos duplicados**. Si tienes `[1, 3, 3, 3, 5]` y quieres insertar 3, tu condición `arr[i] < valor` se detendrá en el primer 3, insertando antes de todos los 3 existentes. ¿Es esto lo que quieres? **Concepto clave**: Debes decidir si quieres insertar **antes** o **después** de elementos iguales. Para insertar después (mantener estabilidad), usa `arr[i] <= valor`. Para insertar antes, tu código actual está bien, pero debes documentar esta decisión. ¿Cuál es el comportamiento esperado con duplicados?"}
{"prompt": "Mi código para contar palabras en una cadena da resultados incorrectos:\n```python\ndef contar_palabras(texto):\n contador = 0\n for char in texto:\n if char == ' ':\n contador += 1\n return contador\n\nprint(contar_palabras('hola mundo')) # Devuelve 1 en lugar de 2\n```", "response": "Tu estrategia de contar separadores (espacios) es creativa, pero tiene un problema conceptual. Si cuentas espacios, ¿cuántos espacios hay entre 2 palabras? Uno. Pero el número de palabras es 2. **Concepto clave**: El número de palabras es típicamente **uno más que el número de espacios** (asumiendo un espacio entre palabras). Pero esto falla con espacios múltiples o espacios al inicio/final. La mejor forma es usar `texto.split()` que maneja estos casos automáticamente, o contar **transiciones** de no-espacio a espacio. ¿Qué estás contando realmente: separadores o palabras?"}
{"prompt": "Mi función para aplanar una lista anidada no funciona completamente:\n```python\ndef aplanar(lista):\n resultado = []\n for elemento in lista:\n if type(elemento) == list:\n for item in elemento:\n resultado.append(item)\n else:\n resultado.append(elemento)\n return resultado\n\nprint(aplanar([1, [2, 3], [4, [5, 6]]])) # Devuelve [1, 2, 3, 4, [5, 6]]\n```", "response": "Tu lógica para un nivel de anidamiento es correcta, pero no maneja **múltiples niveles de anidamiento**. Observa `[4, [5, 6]]`: descompones el primer nivel y obtienes 4 y `[5, 6]`, pero `[5, 6]` sigue siendo una lista anidada que no descompones. **Concepto clave**: Para aplanar completamente listas con cualquier nivel de anidamiento, necesitas **recursión**. Cuando encuentres una lista, debes llamar recursivamente a `aplanar()` sobre ella: `resultado.extend(aplanar(elemento))`. Alternativamente, usa `isinstance(elemento, list)` en lugar de `type()`. ¿Cómo manejarías niveles arbitrarios de anidamiento?"}
{"prompt": "Mi búsqueda de todos los índices de un elemento no funciona:\n```python\ndef encontrar_todos(arr, objetivo):\n indices = []\n for i in range(len(arr)):\n if arr[i] == objetivo:\n indices.append(i)\n arr.remove(objetivo)\n return indices\n\nprint(encontrar_todos([1, 2, 3, 2, 2, 4], 2)) # No encuentra todos los 2\n```", "response": "Tu lógica de búsqueda es correcta, pero hay un error crítico: estás **modificando el array mientras lo iteras**. Cuando encuentras un 2 en la posición 1 y lo eliminas, todos los elementos posteriores se desplazan hacia la izquierda. Pero tu índice `i` sigue incrementándose, ¡saltándose el siguiente 2! **Concepto clave**: Nunca modifiques una estructura de datos mientras la iteras con índices, esto causa comportamiento impredecible. En este caso, simplemente **elimina la línea** `arr.remove(objetivo)` - no necesitas modificar el array para encontrar índices. ¿Por qué estás eliminando elementos si solo quieres sus posiciones?"}
{"prompt": "Mi código para transponer una matriz no funciona:\n```python\ndef transponer(matriz):\n filas = len(matriz)\n columnas = len(matriz[0])\n resultado = []\n for i in range(columnas):\n fila = []\n for j in range(filas):\n fila.append(matriz[i][j])\n resultado.append(fila)\n return resultado\n\nprint(transponer([[1, 2, 3], [4, 5, 6]])) # Da IndexError\n```", "response": "Tu comprensión de dimensiones es correcta (intercambias filas por columnas), pero hay un error en los **índices de acceso**. En la transposición, si la matriz original es `matriz[i][j]`, la transpuesta debe ser `matriz[j][i]`. Observa tu código: usas `matriz[i][j]` cuando `i` va de 0 a columnas-1. ¿Qué pasa si la matriz tiene 2 filas y 3 columnas? Intentarías acceder a `matriz[2][0]`, que no existe. **Concepto clave**: Al transponer, inviertes los índices. El nuevo elemento en posición `[i][j]` viene de `[j][i]` en la matriz original. ¿Qué índices deberías usar para acceder a `matriz`?"}
{"prompt": "Mi función para calcular combinaciones (nCr) da resultados incorrectos:\n```python\ndef combinaciones(n, r):\n if r == 0:\n return 1\n numerador = 1\n denominador = 1\n for i in range(n, n - r, -1):\n numerador *= i\n for i in range(1, r):\n denominador *= i\n return numerador // denominador\n\nprint(combinaciones(5, 2)) # Devuelve 20 en lugar de 10\n```", "response": "Tu enfoque de calcular el numerador y denominador por separado es correcto, y el numerador está bien calculado. Sin embargo, hay un error en el **rango del denominador**. Observa: usas `range(1, r)`, que en el caso de `r=2` solo itera sobre `[1]`, calculando `denominador = 1` en lugar de `1*2 = 2`. **Concepto clave**: `range(1, r)` excluye el valor final `r`. Debes usar `range(1, r + 1)` para incluir `r` en el cálculo factorial. Recuerda que `range(a, b)` va desde `a` hasta `b-1`. ¿Qué valores debería incluir tu range para calcular r! correctamente?"}
{"prompt": "Mi código para verificar si una cadena contiene solo dígitos no funciona:\n```python\ndef solo_digitos(texto):\n digitos = '0123456789'\n for char in texto:\n if char not in digitos:\n return True\n return False\n\nprint(solo_digitos('12345')) # Devuelve False, debería ser True\n```", "response": "Tu lógica de verificación carácter por carácter es correcta, pero los **valores de retorno están invertidos**. Observa: cuando encuentras un carácter que NO es dígito, retornas `True`. Pero la pregunta es '¿solo tiene dígitos?', entonces encontrar un no-dígito debería retornar `False`. Similarmente, si terminas el bucle sin encontrar no-dígitos, significa que todos eran dígitos, entonces deberías retornar `True`. **Concepto clave**: Revisa cuidadosamente la semántica de tu función. Tu lógica detecta 'tiene al menos un no-dígito', pero la función debería verificar 'todos son dígitos'. ¿Qué significa encontrar un carácter que no está en digitos?"}
{"prompt": "Mi implementación de multiplicación de matrices tiene un error:\n```python\ndef multiplicar_matrices(A, B):\n filas_A = len(A)\n columnas_B = len(B[0])\n resultado = [[0 for _ in range(columnas_B)] for _ in range(filas_A)]\n \n for i in range(filas_A):\n for j in range(columnas_B):\n for k in range(len(B)):\n resultado[i][j] += A[i][k] * B[k][j]\n return resultado\n\nA = [[1, 2], [3, 4]]\nB = [[5, 6], [7, 8]]\nprint(multiplicar_matrices(A, B)) # Resultado incorrecto\n```", "response": "Tu estructura de triple bucle es correcta (es el algoritmo estándar), y la inicialización de la matriz resultado está bien. Sin embargo, hay un error sutil en el **tercer bucle**. Observa: usas `range(len(B))`, que te da el número de filas de B. Pero para multiplicación de matrices, necesitas iterar sobre las **columnas de A** (o equivalentemente, las filas de B, que deben ser iguales). **Concepto clave**: Debes usar `range(len(A[0]))` o `range(len(B))` (ambos deben ser iguales para que la multiplicación sea válida). También deberías validar que `len(A[0]) == len(B)`. El error puede estar causando accesos fuera de rango. ¿Qué dimensión debe controlar el bucle más interno?"}
{"prompt": "Mi código para encontrar el primer carácter no repetido falla:\n```python\ndef primer_no_repetido(texto):\n for i in range(len(texto)):\n repetido = False\n for j in range(len(texto)):\n if i != j and texto[i] == texto[j]:\n repetido = True\n if not repetido:\n return texto[i]\n return None\n\nprint(primer_no_repetido('aabbc')) # Funciona lento y tiene un error lógico\n```", "response": "Tu enfoque de doble bucle funciona conceptualmente, pero hay un problema de **eficiencia y lógica**. Con el doble bucle, la complejidad es O(n²), que es ineficiente. Pero más importante: una vez que marcas `repetido = True`, sigues verificando los demás caracteres innecesariamente. Aunque esto no afecta la corrección, es ineficiente. **Concepto clave**: Es mejor usar un diccionario para contar frecuencias en una pasada (O(n)), luego iterar el texto de nuevo buscando el primero con frecuencia 1. Esto es O(n) vs O(n²). Tu código funciona pero ¿podrías optimizarlo usando un diccionario de conteo?"}
{"prompt": "Mi código para rotar una matriz 90 grados no funciona:\n```python\ndef rotar_90(matriz):\n n = len(matriz)\n for i in range(n):\n for j in range(n):\n matriz[i][j], matriz[j][i] = matriz[j][i], matriz[i][j]\n return matriz\n\nprint(rotar_90([[1, 2], [3, 4]])) # No rota correctamente\n```", "response": "Intentas hacer algo parecido a una transposición con el intercambio, pero hay dos problemas: (1) estás intercambiando elementos **dos veces** (cuando i=0,j=1 y cuando i=1,j=0), lo que deshace el cambio, y (2) rotar 90° no es solo transponer, también necesitas **invertir filas o columnas**. **Concepto clave**: Para rotar 90° en sentido horario: primero transpone (intercambia filas por columnas) iterando solo la mitad superior (`j > i`), luego invierte cada fila. Para antihorario: transpone y luego invierte columnas. La transposición simple no es suficiente. ¿Qué dos operaciones necesitas combinar?"}
{"prompt": "Mi función para calcular la mediana de un array no funciona:\n```python\ndef mediana(arr):\n arr.sort()\n n = len(arr)\n if n % 2 == 1:\n return arr[n / 2]\n else:\n return (arr[n / 2] + arr[n / 2 - 1]) / 2\n\nprint(mediana([3, 1, 4, 1, 5])) # Da error de tipo\n```", "response": "Tu lógica para encontrar la mediana es correcta: ordenas, verificas si es impar o par, y calculas apropiadamente. Sin embargo, hay un error de **tipo de dato** en los índices. En Python 3, la división `/` retorna un float, incluso si el resultado es entero. Entonces `n / 2` te da `2.5` o `2.0`, pero los índices de lista deben ser enteros. **Concepto clave**: Debes usar división entera `//` para obtener índices: `arr[n // 2]`. Esto es especialmente importante en Python 3 donde `/` siempre produce floats. ¿Qué operador deberías usar para obtener índices enteros?"}
{"prompt": "Mi código para encontrar el elemento mayoritario (aparece >n/2 veces) no funciona:\n```python\ndef elemento_mayoritario(arr):\n n = len(arr)\n for num in arr:\n contador = 0\n for elemento in arr:\n if elemento == num:\n contador += 1\n if contador > n / 2:\n return num\n return None\n\nprint(elemento_mayoritario([3, 3, 4, 2, 4, 4, 2, 4, 4])) # Funciona pero es ineficiente\n```", "response": "Tu algoritmo es correcto y encuentra el elemento mayoritario, pero tiene una **complejidad terrible** de O(n²). Para cada elemento, cuentas cuántas veces aparece en todo el array. Si el array tiene 10,000 elementos, harás 100 millones de comparaciones. **Concepto clave**: Puedes optimizarlo a O(n) usando un diccionario para contar frecuencias en una sola pasada, o usar el algoritmo de Boyer-Moore que es O(n) tiempo y O(1) espacio. Tu código funciona pero ¿podrías hacerlo más eficiente evitando el doble bucle?"}
{"prompt": "Mi implementación de partición para quicksort tiene un bug:\n```python\ndef particion(arr, bajo, alto):\n pivote = arr[alto]\n i = bajo\n for j in range(bajo, alto):\n if arr[j] < pivote:\n arr[i], arr[j] = arr[j], arr[i]\n i += 1\n arr[i], arr[alto] = arr[alto], arr[i]\n return i\n\narr = [10, 7, 8, 9, 1, 5]\nprint(particion(arr, 0, len(arr)-1)) # Parece correcto pero hay un problema conceptual\n```", "response": "Tu implementación de la partición de Hoare modificada es casi correcta. El algoritmo coloca elementos menores que el pivote a la izquierda y mayores a la derecha. Sin embargo, hay una pregunta sobre **elementos iguales al pivote**. Tu condición `if arr[j] < pivote` coloca elementos menores a la izquierda, pero ¿qué pasa con elementos iguales al pivote? Se quedan donde están (lado derecho). Esto puede causar desbalance si hay muchos duplicados. **Concepto clave**: Para mejor balance con duplicados, considera usar `<=` en lugar de `<`, alternando la dirección de elementos iguales. Sin embargo, tu código técnicamente funciona. ¿Has considerado cómo se comporta con muchos valores duplicados?"}
{"prompt": "Mi código para verificar si un número es perfecto (suma de divisores = número) no funciona:\n```python\ndef es_perfecto(n):\n suma = 0\n for i in range(1, n):\n if n % i == 0:\n suma += i\n return suma == n\n\nprint(es_perfecto(28)) # Funciona pero es muy lento para números grandes\n```", "response": "Tu algoritmo es correcto: sumas todos los divisores propios y verificas si igualan el número. Sin embargo, es muy **ineficiente** para números grandes. Si verificas si 10,000,000 es perfecto, iteras 10 millones de veces. **Concepto clave**: Solo necesitas verificar divisores hasta √n. Cuando encuentras un divisor `i`, también encuentras su par `n/i`. Entonces puedes iterar solo hasta `int(n**0.5)` y agregar ambos divisores (cuidando no duplicar la raíz cuadrada). Esto reduce la complejidad de O(n) a O(√n). ¿Puedes optimizar iterando solo hasta la raíz cuadrada?"}
{"prompt": "Mi función para mezclar dos arrays ordenados en zigzag no funciona:\n```python\ndef zigzag(arr1, arr2):\n resultado = []\n for i in range(len(arr1)):\n resultado.append(arr1[i])\n resultado.append(arr2[i])\n return resultado\n\nprint(zigzag([1, 2, 3], [4, 5])) # Da IndexError\n```", "response": "Tu estrategia de alternar elementos es correcta, pero asumes que ambos arrays tienen la **misma longitud**. ¿Qué pasa si `arr1` tiene 3 elementos y `arr2` solo 2? Cuando `i=2`, intentas acceder a `arr2[2]` que no existe. **Concepto clave**: Debes iterar solo hasta la longitud del array más corto usando `min(len(arr1), len(arr2))`, y luego agregar los elementos restantes del array más largo. O usa un enfoque con índices separados para cada array. ¿Cómo manejarías arrays de diferentes longitudes?"}
{"prompt": "Mi código para encontrar tres números que sumen cero no funciona correctamente:\n```python\ndef tres_suma_cero(arr):\n resultado = []\n for i in range(len(arr)):\n for j in range(len(arr)):\n for k in range(len(arr)):\n if i != j and j != k and i != k:\n if arr[i] + arr[j] + arr[k] == 0:\n resultado.append([arr[i], arr[j], arr[k]])\n return resultado\n\nprint(tres_suma_cero([-1, 0, 1, 2, -1, -4])) # Tiene duplicados como [-1,0,1] y [0,1,-1]\n```", "response": "Tu triple bucle encuentra todas las combinaciones de tres números, pero hay dos problemas: (1) generas **tripletas duplicadas** en diferente orden ([-1,0,1] y [0,1,-1] son la misma tripleta), y (2) la complejidad es O(n³), muy ineficiente. **Concepto clave**: Para evitar duplicados, primero ordena el array y usa `k > j > i` en los ranges (`j in range(i+1, len(arr))` y `k in range(j+1, len(arr))`). Esto asegura orden y evita permutaciones. Mejor aún, usa un enfoque de dos punteros después de fijar un elemento, reduciendo a O(n²). ¿Cómo evitarías contar la misma tripleta múltiples veces?"}
{"prompt": "Mi función para comprimir una cadena (aaabbcc -> a3b2c2) no maneja bien casos especiales:\n```python\ndef comprimir(texto):\n if len(texto) == 0:\n return texto\n resultado = ''\n contador = 1\n for i in range(1, len(texto)):\n if texto[i] == texto[i-1]:\n contador += 1\n else:\n resultado += texto[i-1] + str(contador)\n contador = 1\n return resultado\n\nprint(comprimir('aaabbcc')) # Devuelve 'a3b2' sin incluir c2\n```", "response": "Tu lógica de conteo y detección de cambios es correcta, pero hay un problema clásico de **procesamiento del último grupo**. Observa: tu bucle va desde índice 1 hasta `len(texto)-1`, y solo agregas al resultado cuando detectas un **cambio** de carácter. ¿Qué pasa con el último grupo de caracteres? Cuando el bucle termina, el último grupo (c2 en tu ejemplo) nunca se procesa porque no hay un siguiente carácter diferente que dispare la condición. **Concepto clave**: Después del bucle, debes agregar el último grupo: `resultado += texto[-1] + str(contador)`. Este es un patrón común en algoritmos de procesamiento secuencial. ¿Qué te falta después del bucle?"}
{"prompt": "Mi búsqueda binaria recursiva en un array rotado no funciona:\n```python\ndef busqueda_rotado(arr, objetivo, inicio, fin):\n if inicio > fin:\n return -1\n medio = (inicio + fin) // 2\n if arr[medio] == objetivo:\n return medio\n if arr[inicio] <= arr[medio]:\n if objetivo >= arr[inicio] and objetivo < arr[medio]:\n return busqueda_rotado(arr, objetivo, inicio, medio - 1)\n return busqueda_rotado(arr, objetivo, medio + 1, fin)\n else:\n if objetivo > arr[medio] and objetivo <= arr[fin]:\n return busqueda_rotado(arr, objetivo, medio + 1, fin)\n return busqueda_rotado(arr, objetivo, inicio, medio - 1)\n\nprint(busqueda_rotado([4,5,6,7,0,1,2], 0, 0, 6)) # A veces no encuentra el elemento\n```", "response": "Tu comprensión de búsqueda binaria en array rotado es sofisticada: identificas qué mitad está ordenada y decides dónde buscar. Sin embargo, hay un caso borde problemático. Cuando tienes **elementos duplicados**, la condición `arr[inicio] <= arr[medio]` no te dice con certeza qué mitad está ordenada. Por ejemplo, si arr[inicio] == arr[medio], podrían ser duplicados o el punto de rotación podría estar entre ellos. **Concepto clave**: Tu código funciona para arrays sin duplicados, pero falla con duplicados porque no puedes determinar qué mitad es la ordenada. Necesitarías verificaciones adicionales o incrementar inicio/decrementar fin cuando son iguales. ¿Cómo manejarías el caso arr[inicio] == arr[medio] == arr[fin]?"}
{"prompt": "Mi código para encontrar el k-ésimo elemento más grande usa ordenamiento:\n```python\ndef k_mas_grande(arr, k):\n arr.sort()\n return arr[len(arr) - k]\n\nprint(k_mas_grande([3,2,1,5,6,4], 2)) # Funciona pero hay un problema\n```", "response": "Tu solución es correcta y funciona: ordenas el array y accedes al k-ésimo elemento desde el final. Sin embargo, hay una cuestión de **eficiencia**. Ordenar tiene complejidad O(n log n), pero solo necesitas encontrar un elemento. **Concepto clave**: Existen algoritmos más eficientes como QuickSelect con complejidad promedio O(n), o usar un heap de tamaño k con complejidad O(n log k). Para k pequeño y n grande, estos son mucho más rápidos. Además, tu solución **modifica el array original** con sort(), lo que podría no ser deseable. ¿Es necesario ordenar todo el array para encontrar un solo elemento?"}
{"prompt": "Mi función para validar sudoku no funciona completamente:\n```python\ndef validar_sudoku(tablero):\n for i in range(9):\n fila = []\n for j in range(9):\n if tablero[i][j] != '.':\n if tablero[i][j] in fila:\n return False\n fila.append(tablero[i][j])\n return True\n\nprint(validar_sudoku(tablero_ejemplo)) # Solo valida filas, faltan columnas y subcuadros\n```", "response": "Tu validación de filas es perfecta: verificas que no haya duplicados en cada fila. Sin embargo, un sudoku válido requiere tres verificaciones: (1) filas sin duplicados, (2) **columnas sin duplicados**, y (3) **subcuadros 3x3 sin duplicados**. Tu código solo hace la primera. **Concepto clave**: Necesitas agregar dos bucles más similares: uno que recorra columnas `tablero[j][i]` y otro que valide los 9 subcuadros 3x3. Para los subcuadros, puedes usar `tablero[3*(i//3) + j//3][3*(i%3) + j%3]` o bucles anidados más claros. ¿Qué dos validaciones adicionales te faltan?"}
{"prompt": "Mi código para generar números de Fibonacci hasta n términos tiene desbordamiento:\n```python\ndef fibonacci_hasta(n):\n if n <= 0:\n return []\n if n == 1:\n return [0]\n fib = [0, 1]\n for i in range(2, n):\n fib.append(fib[i-1] + fib[i-2])\n return fib\n\nprint(fibonacci_hasta(1000)) # Los números se vuelven enormes\n```", "response": "Tu algoritmo es correcto y genera la secuencia de Fibonacci perfectamente. Sin embargo, mencionas 'desbordamiento', pero en Python los enteros tienen **precisión arbitraria**, es decir, pueden crecer indefinidamente sin desbordarse (a diferencia de C++ o Java). Los números de Fibonacci crecen exponencialmente, entonces fibonacci(1000) será astronómicamente grande, pero Python lo manejará. **Concepto clave**: Si el problema es el tamaño de los números, puedes aplicar módulo en cada paso (`fib[i] % MOD`) para mantenerlos manejables, pero esto solo funciona si no necesitas los valores exactos. ¿Realmente hay un error o solo son números muy grandes?"}
{"prompt": "Mi implementación de cola circular no maneja correctamente el caso de cola llena:\n```python\nclass ColaCircular:\n def __init__(self, k):\n self.cola = [None] * k\n self.frente = 0\n self.fin = 0\n self.tamaño = 0\n self.capacidad = k\n \n def encolar(self, valor):\n if self.tamaño == self.capacidad:\n return False\n self.cola[self.fin] = valor\n self.fin = (self.fin + 1) % self.capacidad\n self.tamaño += 1\n return True\n \n def desencolar(self):\n if self.tamaño == 0:\n return False\n self.frente = (self.frente + 1) % self.capacidad\n self.tamaño -= 1\n return True\n\ncola = ColaCircular(3)\nprint(cola.encolar(1)) # True\nprint(cola.encolar(2)) # True \nprint(cola.encolar(3)) # True\nprint(cola.desencolar()) # True\nprint(cola.encolar(4)) # Debería ser True pero puede haber confusión\n```", "response": "Tu implementación de cola circular es casi perfecta: usas aritmética modular para los índices y mantienes un contador de tamaño para distinguir entre llena y vacía. Sin embargo, quiero verificar tu comprensión del caso **llena vs vacía**. Algunas implementaciones no usan contador de tamaño y en su lugar verifican `(fin + 1) % capacidad == frente`, pero esto tiene la ambigüedad de que tanto llena como vacía tendrían `frente == fin`. **Concepto clave**: Tu uso de `self.tamaño` resuelve elegantemente esta ambigüedad. Tu código parece correcto. ¿Estás experimentando algún comportamiento inesperado específico o solo querías validar la lógica?"}
{"prompt": "Mi código para encontrar el camino más largo en un árbol binario no funciona:\n```python\nclass Nodo:\n def __init__(self, valor):\n self.valor = valor\n self.izq = None\n self.der = None\n\ndef camino_mas_largo(raiz):\n if raiz is None:\n return 0\n izq = camino_mas_largo(raiz.izq)\n der = camino_mas_largo(raiz.der)\n return 1 + max(izq, der)\n\nraiz = Nodo(1)\nraiz.izq = Nodo(2)\nraiz.der = Nodo(3)\nraiz.izq.izq = Nodo(4)\nprint(camino_mas_largo(raiz)) # Funciona para altura pero ¿es esto el camino más largo?\n```", "response": "Tu función calcula correctamente la **altura** del árbol (camino más largo desde la raíz hasta una hoja), pero hay ambigüedad en el término 'camino más largo'. Si te refieres al camino más largo **entre dos nodos cualesquiera** (diámetro del árbol), tu función no es suficiente. **Concepto clave**: El diámetro puede no pasar por la raíz. Para cada nodo, el camino más largo que pasa por él es `altura_izq + altura_der`. Necesitas calcular esto para todos los nodos y tomar el máximo global. Tu función actual solo da la altura. ¿'Camino más largo' significa altura o diámetro del árbol?"}
{"prompt": "Mi función para eliminar vocales de una cadena no funciona con mayúsculas:\n```python\ndef eliminar_vocales(texto):\n vocales = 'aeiou'\n resultado = ''\n for char in texto:\n if char not in vocales:\n resultado += char\n return resultado\n\nprint(eliminar_vocales('Hola Mundo')) # Devuelve 'Hl Mnd', las mayúsculas no se eliminan\n```", "response": "Tu lógica es correcta para vocales minúsculas, pero no consideras las **mayúsculas**. Tu cadena `vocales` solo tiene 'aeiou' minúsculas, entonces 'O' y 'U' no se detectan como vocales. **Concepto clave**: Necesitas incluir también las mayúsculas: `vocales = 'aeiouAEIOU'`. Alternativamente, puedes convertir cada carácter a minúscula antes de verificar: `char.lower() not in vocales`, pero entonces deberías mantener el carácter original en el resultado. La primera opción (incluir ambos casos) es más simple. ¿Cómo manejarías ambos casos de vocales?"}
{"prompt": "Mi código para encontrar la subsecuencia común más larga (LCS) recursiva es muy lento:\n```python\ndef lcs(s1, s2, m, n):\n if m == 0 or n == 0:\n return 0\n if s1[m-1] == s2[n-1]:\n return 1 + lcs(s1, s2, m-1, n-1)\n else:\n return max(lcs(s1, s2, m, n-1), lcs(s1, s2, m-1, n))\n\nprint(lcs('AGGTAB', 'GXTXAYB', 6, 7)) # Funciona pero muy lento\n```", "response": "Tu implementación recursiva del LCS es correcta en lógica: compara caracteres y recorre ambas opciones. Sin embargo, tiene **subproblemas superpuestos** que se calculan repetidamente, causando complejidad exponencial O(2^(m+n)). Para cadenas largas, será extremadamente lento. **Concepto clave**: Necesitas **memoización** (guardar resultados en un diccionario) o **programación dinámica** (tabla bottom-up) para reducir la complejidad a O(m*n). Sin optimización, tu función recalcula los mismos subproblemas miles de veces. ¿Cómo podrías evitar recalcular los mismos pares (m,n) múltiples veces?"}
{"prompt": "Mi función para verificar si un número es Armstrong (narcisista) no funciona:\n```python\ndef es_armstrong(n):\n suma = 0\n temp = n\n digitos = len(str(n))\n while temp > 0:\n digito = temp % 10\n suma += digito ** digitos\n temp = temp / 10\n return suma == n\n\nprint(es_armstrong(153)) # Da error o comportamiento incorrecto\n```", "response": "Tu algoritmo es correcto: extraes cada dígito, lo elevas a la potencia del número de dígitos, y sumas. Sin embargo, hay un error de **tipo de dato**. Observa `temp = temp / 10`: esto produce un float en Python 3, entonces en la siguiente iteración `temp % 10` no funcionará correctamente con un float (aunque técnicamente funciona, es conceptualmente incorrecto). **Concepto clave**: Debes usar división entera `temp = temp // 10` para mantener `temp` como entero. Este es un error común al migrar de Python 2 (donde `/` era división entera) a Python 3. ¿Qué operador deberías usar para mantener variables enteras?"}
{"prompt": "Mi código para encontrar todos los subconjuntos de un conjunto no funciona:\n```python\ndef subconjuntos(nums):\n resultado = []\n def backtrack(inicio, subconjunto):\n resultado.append(subconjunto)\n for i in range(inicio, len(nums)):\n subconjunto.append(nums[i])\n backtrack(i + 1, subconjunto)\n subconjunto.pop()\n backtrack(0, [])\n return resultado\n\nprint(subconjuntos([1,2,3])) # Los subconjuntos se modifican entre sí\n```", "response": "Tu implementación de backtracking es casi correcta: agregas elementos, recurres, y haces backtrack con pop(). Sin embargo, hay un problema sutil con las **referencias**. Cuando haces `resultado.append(subconjunto)`, estás agregando una **referencia** al mismo objeto lista, no una copia. Entonces todas las modificaciones posteriores afectan a todas las 'copias'. **Concepto clave**: Debes agregar una copia: `resultado.append(subconjunto[:])` o `resultado.append(list(subconjunto))`. En Python, las listas son mutables y se pasan por referencia, entonces modificar el original modifica todas las referencias. ¿Estás agregando copias o referencias?"}
{"prompt": "Explícame búsqueda binaria con un ejemplo en Python.", "response": "Búsqueda binaria divide repetidamente el rango a la mitad. Solo funciona en arrays ordenados. Ejemplo:\n```python\ndef busqueda_binaria(arr, objetivo):\n izq, der = 0, len(arr) - 1\n while izq <= der:\n medio = (izq + der) // 2\n if arr[medio] == objetivo:\n return medio\n elif arr[medio] < objetivo:\n izq = medio + 1\n else:\n der = medio - 1\n return -1\n```\nBusca en [1,3,5,7,9] el 7: compara con 5 (medio), luego con 7. Encuentra en 2 pasos vs 4 de búsqueda lineal."}
{"prompt": "¿Cómo funciona el algoritmo de ordenamiento burbuja?", "response": "Burbuja compara pares adyacentes y los intercambia si están en orden incorrecto. Repite hasta que no haya intercambios. El elemento mayor 'burbujea' al final en cada pasada. Complejidad O(n²). Ejemplo en Java:\n```java\nvoid burbuja(int[] arr) {\n int n = arr.length;\n for (int i = 0; i < n-1; i++) {\n for (int j = 0; j < n-i-1; j++) {\n if (arr[j] > arr[j+1]) {\n int temp = arr[j];\n arr[j] = arr[j+1];\n arr[j+1] = temp;\n }\n }\n }\n}\n```\nNo es eficiente para grandes volúmenes, pero es simple de entender."}
{"prompt": "Dame un ejercicio de recursión con arrays en Python.", "response": "Ejercicio: Escribe una función recursiva que sume todos los elementos de un array.\n\nPista: El caso base es cuando el array está vacío (retorna 0). El caso recursivo suma el primer elemento más la suma del resto del array.\n\n¿Puedes implementarlo? Debería verse así:\n```python\ndef sumar_recursivo(arr):\n if len(arr) == 0:\n return 0\n return arr[0] + sumar_recursivo(arr[1:])\n```\nPrueba con [1, 2, 3, 4, 5]. Debería devolver 15."}
{"prompt": "¿Qué diferencia hay entre pila (stack) y cola (queue)?", "response": "Pila es LIFO (Last In, First Out): el último en entrar es el primero en salir, como una pila de platos. Cola es FIFO (First In, First Out): el primero en entrar es el primero en salir, como una fila de personas.\n\nPila en Python:\n```python\npila = []\npila.append(1) # push\npila.pop() # pop último\n```\n\nCola en Python:\n```python\nfrom collections import deque\ncola = deque()\ncola.append(1) # encolar\ncola.popleft() # desencolar primero\n```\nPilas se usan en recursión, deshacer/rehacer. Colas en procesamiento de tareas, BFS."}
{"prompt": "Explícame el algoritmo QuickSort de forma simple.", "response": "QuickSort usa divide y vencerás:\n1. Elige un 'pivote' del array\n2. Particiona: elementos menores a la izquierda, mayores a la derecha\n3. Recursivamente ordena ambas particiones\n\nEjemplo en C:\n```c\nvoid quicksort(int arr[], int izq, int der) {\n if (izq < der) {\n int pivote = particionar(arr, izq, der);\n quicksort(arr, izq, pivote - 1);\n quicksort(arr, pivote + 1, der);\n }\n}\n```\nComplejidad promedio O(n log n), peor caso O(n²). Es muy eficiente en la práctica y se usa ampliamente."}
{"prompt": "¿Cómo implemento una lista enlazada simple en Java?", "response": "Una lista enlazada tiene nodos, cada uno con dato y referencia al siguiente:\n```java\nclass Nodo {\n int dato;\n Nodo siguiente;\n \n Nodo(int dato) {\n this.dato = dato;\n this.siguiente = null;\n }\n}\n\nclass ListaEnlazada {\n Nodo cabeza;\n \n void insertar(int dato) {\n Nodo nuevo = new Nodo(dato);\n nuevo.siguiente = cabeza;\n cabeza = nuevo;\n }\n \n void imprimir() {\n Nodo actual = cabeza;\n while (actual != null) {\n System.out.print(actual.dato + \" -> \");\n actual = actual.siguiente;\n }\n }\n}\n```\nVentaja: inserción/eliminación O(1) al inicio. Desventaja: acceso O(n)."}
{"prompt": "Dame un ejercicio de ordenamiento para practicar en Python.", "response": "Ejercicio: Implementa Selection Sort (ordenamiento por selección).\n\nAlgoritmo:\n1. Encuentra el elemento mínimo en el array\n2. Intercámbialo con el primer elemento\n3. Repite con el resto del array (desde posición 2, 3, etc.)\n\nFirma de función:\n```python\ndef selection_sort(arr):\n # Tu código aquí\n pass\n```\n\nPrueba con: [64, 25, 12, 22, 11]\nDebe retornar: [11, 12, 22, 25, 64]\n\nPista: Usa dos bucles, el externo para cada posición, el interno para encontrar el mínimo."}
{"prompt": "¿Qué es BFS (Breadth-First Search) y cuándo usarlo?", "response": "BFS explora un grafo nivel por nivel, visitando todos los vecinos antes de bajar al siguiente nivel. Usa una cola.\n\nImplementación básica en Python:\n```python\nfrom collections import deque\n\ndef bfs(grafo, inicio):\n visitados = set()\n cola = deque([inicio])\n \n while cola:\n nodo = cola.popleft()\n if nodo not in visitados:\n print(nodo)\n visitados.add(nodo)\n cola.extend(grafo[nodo])\n```\n\nUsalo para:\n- Encontrar camino más corto (en grafos sin pesos)\n- Verificar si un grafo es conexo\n- Nivel por nivel en árboles\n\nComplejidad: O(V + E) donde V=vértices, E=aristas."}
{"prompt": "Explícame el algoritmo de Dijkstra con un ejemplo.", "response": "Dijkstra encuentra el camino más corto desde un nodo origen a todos los demás en un grafo con pesos positivos.\n\nPasos:\n1. Marca todos los nodos como distancia infinita, excepto el origen (0)\n2. Selecciona el nodo no visitado con menor distancia\n3. Actualiza distancias de sus vecinos\n4. Marca como visitado y repite\n\nEjemplo: Grafo A→B(4), A→C(2), C→B(1), C→D(5)\nDesde A: A=0, C=2, B=3 (vía C), D=7\n\nImplementación completa es extensa, pero usa una cola de prioridad (heap) para eficiencia O((V+E) log V). Python tiene heapq para esto."}
{"prompt": "¿Cómo verifico si un array está ordenado en C?", "response": "Recorre el array comparando cada elemento con el siguiente:\n```c\n#include <stdbool.h>\n\nbool esta_ordenado(int arr[], int n) {\n for (int i = 0; i < n - 1; i++) {\n if (arr[i] > arr[i + 1]) {\n return false;\n }\n }\n return true;\n}\n```\n\nPuntos clave:\n- Itera hasta n-1 para evitar acceso fuera de límites\n- Retorna false en la primera violación\n- Complejidad O(n)\n- Funciona para orden ascendente, cambia > a < para descendente\n\nPrueba: [1,2,3,4,5] → true, [1,3,2,4] → false"}
{"prompt": "Dame un ejercicio de recursión con strings en Java.", "response": "Ejercicio: Escribe una función recursiva que invierta un string.\n\nFirma:\n```java\npublic static String invertir(String str) {\n // Tu código aquí\n}\n```\n\nPistas:\n- Caso base: si el string está vacío o tiene 1 carácter, retórnalo\n- Caso recursivo: toma el último carácter + invertir el resto\n- Usa substring() para extraer partes\n\nSolución esperada:\n```java\npublic static String invertir(String str) {\n if (str.isEmpty()) return str;\n return str.charAt(str.length()-1) + invertir(str.substring(0, str.length()-1));\n}\n```\n\nPrueba con: \"hola\" → \"aloh\""}
{"prompt": "¿Qué es DFS (Depth-First Search) y cómo se diferencia de BFS?", "response": "DFS explora un grafo yendo lo más profundo posible antes de retroceder. Usa una pila (o recursión).\n\nDFS recursivo en Python:\n```python\ndef dfs(grafo, nodo, visitados=None):\n if visitados is None:\n visitados = set()\n \n visitados.add(nodo)\n print(nodo)\n \n for vecino in grafo[nodo]:\n if vecino not in visitados:\n dfs(grafo, vecino, visitados)\n```\n\nDiferencias con BFS:\n- DFS usa pila (LIFO), BFS usa cola (FIFO)\n- DFS va profundo, BFS va por niveles\n- DFS mejor para detectar ciclos, explorar todos los caminos\n- BFS mejor para camino más corto\n\nAmbos son O(V + E)."}
{"prompt": "Explícame el algoritmo de Merge Sort paso a paso.", "response": "Merge Sort usa divide y vencerás:\n\n1. **Divide**: Parte el array a la mitad recursivamente hasta tener subarrays de 1 elemento\n2. **Conquista**: Fusiona pares de subarrays ordenándolos\n3. **Combina**: Repite hasta tener un array ordenado completo\n\nEjemplo en Python:\n```python\ndef merge_sort(arr):\n if len(arr) <= 1:\n return arr\n \n medio = len(arr) // 2\n izq = merge_sort(arr[:medio])\n der = merge_sort(arr[medio:])\n \n return merge(izq, der)\n\ndef merge(izq, der):\n resultado = []\n i = j = 0\n \n while i < len(izq) and j < len(der):\n if izq[i] < der[j]:\n resultado.append(izq[i])\n i += 1\n else:\n resultado.append(der[j])\n j += 1\n \n resultado.extend(izq[i:])\n resultado.extend(der[j:])\n return resultado\n```\n\nComplejidad siempre O(n log n), estable, usa O(n) memoria adicional."}
{"prompt": "¿Cómo implemento una tabla hash simple en C?", "response": "Una tabla hash usa una función hash para mapear claves a índices. Ejemplo simple con array de tamaño fijo:\n\n```c\n#define TAMANIO 10\n\ntypedef struct {\n int clave;\n int valor;\n int ocupado;\n} Entrada;\n\nEntrada tabla[TAMANIO];\n\nint hash(int clave) {\n return clave % TAMANIO;\n}\n\nvoid insertar(int clave, int valor) {\n int indice = hash(clave);\n tabla[indice].clave = clave;\n tabla[indice].valor = valor;\n tabla[indice].ocupado = 1;\n}\n\nint buscar(int clave) {\n int indice = hash(clave);\n if (tabla[indice].ocupado && tabla[indice].clave == clave)\n return tabla[indice].valor;\n return -1; // No encontrado\n}\n```\n\nEsto es básico, no maneja colisiones. Para producción usa chaining o open addressing."}
{"prompt": "Dame un ejercicio de pilas (stacks) en Python nivel intermedio.", "response": "Ejercicio: Implementa una función que evalúe si una expresión matemática tiene paréntesis balanceados, considerando (), [], {}.\n\nFirma:\n```python\ndef parentesis_balanceados(expresion):\n # Tu código aquí\n pass\n```\n\nEjemplos:\n- \"(a + b) * [c - d]\" → True\n- \"((a + b)\" → False\n- \"{a + [b * (c - d)]}\" → True\n- \"(a + b])\" → False\n\nPista: Usa una pila. Push cuando encuentres apertura, pop y verifica coincidencia con cierre. Si la pila queda vacía al final, está balanceado.\n\nEsto es común en parsers y compiladores."}
{"prompt": "¿Qué es programación dinámica y cuándo usarla?", "response": "Programación dinámica resuelve problemas dividiéndolos en subproblemas superpuestos, guardando resultados para no recalcular (memoization).\n\nCuándo usar:\n- Hay subproblemas que se repiten\n- Tiene subestructura óptima\n- Ejemplos: Fibonacci, problema de la mochila, subsecuencia común más larga\n\nFibonacci sin DP: O(2^n)\n```python\ndef fib(n):\n if n <= 1: return n\n return fib(n-1) + fib(n-2)\n```\n\nFibonacci con DP: O(n)\n```python\ndef fib_dp(n, memo={}):\n if n in memo: return memo[n]\n if n <= 1: return n\n memo[n] = fib_dp(n-1, memo) + fib_dp(n-2, memo)\n return memo[n]\n```\n\nLa diferencia de velocidad es dramática para n grandes."}
{"prompt": "Explícame el algoritmo de búsqueda en amplitud (BFS) en árboles binarios.", "response": "BFS en árboles recorre nivel por nivel de izquierda a derecha usando una cola.\n\nImplementación en Java:\n```java\nimport java.util.*;\n\nclass Nodo {\n int dato;\n Nodo izq, der;\n Nodo(int d) { dato = d; }\n}\n\nvoid bfs(Nodo raiz) {\n if (raiz == null) return;\n \n Queue<Nodo> cola = new LinkedList<>();\n cola.add(raiz);\n \n while (!cola.isEmpty()) {\n Nodo actual = cola.poll();\n System.out.print(actual.dato + \" \");\n \n if (actual.izq != null) cola.add(actual.izq);\n if (actual.der != null) cola.add(actual.der);\n }\n}\n```\n\nPara árbol:\n```\n 1\n / \\\n 2 3\n / \\\n 4 5\n```\nImprime: 1 2 3 4 5\n\nComplejidad: O(n) tiempo, O(w) espacio donde w es el ancho máximo del árbol."}
{"prompt": "Dame un ejercicio de ordenamiento con restricciones en C.", "response": "Ejercicio: Implementa Insertion Sort pero que ordene un array de structs de estudiantes por calificación descendente.\n\nStruct:\n```c\ntypedef struct {\n char nombre[50];\n float calificacion;\n} Estudiante;\n```\n\nFirma:\n```c\nvoid ordenar_estudiantes(Estudiante arr[], int n) {\n // Tu código aquí\n}\n```\n\nPrueba con:\n```c\nEstudiante estudiantes[] = {\n {\"Ana\", 8.5},\n {\"Carlos\", 9.2},\n {\"Beatriz\", 7.8}\n};\n```\n\nDebe quedar: Carlos (9.2), Ana (8.5), Beatriz (7.8)\n\nPista: Compara `arr[j].calificacion > arr[j-1].calificacion` para orden descendente."}
{"prompt": "¿Cómo funciona el algoritmo de Floyd-Warshall?", "response": "Floyd-Warshall encuentra caminos más cortos entre todos los pares de nodos en un grafo (incluso con pesos negativos, pero sin ciclos negativos).\n\nAlgoritmo:\nPara cada nodo k como intermediario:\n Para cada par (i, j):\n Si dist[i][k] + dist[k][j] < dist[i][j]:\n Actualiza dist[i][j]\n\nImplementación en Python:\n```python\ndef floyd_warshall(grafo):\n n = len(grafo)\n dist = [fila[:] for fila in grafo] # Copia\n \n for k in range(n):\n for i in range(n):\n for j in range(n):\n dist[i][j] = min(dist[i][j], \n dist[i][k] + dist[k][j])\n return dist\n```\n\nComplejidad: O(n³)\nUsa matriz de adyacencia con infinito para aristas inexistentes.\nÚtil para grafos densos y pequeños."}
